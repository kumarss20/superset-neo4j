"use strict";

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _interweave = require("interweave");

var _emojibaseRegex = _interopRequireDefault(require("emojibase-regex"));

var _emoticon = _interopRequireDefault(require("emojibase-regex/emoticon"));

var _shortcode = _interopRequireDefault(require("emojibase-regex/shortcode"));

var _Emoji = _interopRequireDefault(require("./Emoji"));

var _EmojiDataManager = _interopRequireDefault(require("./EmojiDataManager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var EMOTICON_BOUNDARY_REGEX = new RegExp("(^|\\\b|\\s)(" + _emoticon.default.source + ")(?=\\s|\\\b|$)");

var EmojiMatcher = function (_Matcher) {
  _inheritsLoose(EmojiMatcher, _Matcher);

  function EmojiMatcher(name, options, factory) {
    var _this;

    _this = _Matcher.call(this, name, _extends({
      convertEmoticon: false,
      convertShortcode: false,
      convertUnicode: false,
      enlargeThreshold: 1,
      renderUnicode: false
    }, options), factory) || this;

    _defineProperty(_assertThisInitialized(_this), "data", null);

    _defineProperty(_assertThisInitialized(_this), "greedy", true);

    return _this;
  }

  var _proto = EmojiMatcher.prototype;

  _proto.replaceWith = function replaceWith(children, props) {
    return _react.default.createElement(_Emoji.default, _extends({}, props, {
      renderUnicode: this.options.renderUnicode
    }));
  };

  _proto.asTag = function asTag() {
    return 'img';
  };

  _proto.match = function match(string) {
    var response = null;

    if (this.options.convertEmoticon) {
      response = this.matchEmoticon(string);

      if (response) {
        return response;
      }
    }

    if (this.options.convertShortcode) {
      response = this.matchShortcode(string);

      if (response) {
        return response;
      }
    }

    if (this.options.convertUnicode) {
      response = this.matchUnicode(string);

      if (response) {
        return response;
      }
    }

    return null;
  };

  _proto.matchEmoticon = function matchEmoticon(string) {
    var response = this.doMatch(string, EMOTICON_BOUNDARY_REGEX, function (matches) {
      return {
        emoticon: matches[0].trim()
      };
    }, true);

    if (response && response.emoticon && this.data && this.data.EMOTICON_TO_HEXCODE[response.emoticon]) {
      response.hexcode = this.data.EMOTICON_TO_HEXCODE[response.emoticon];
      response.match = String(response.emoticon);
      return response;
    }

    return null;
  };

  _proto.matchShortcode = function matchShortcode(string) {
    var response = this.doMatch(string, _shortcode.default, function (matches) {
      return {
        shortcode: matches[0].toLowerCase()
      };
    }, true);

    if (response && response.shortcode && this.data && this.data.SHORTCODE_TO_HEXCODE[response.shortcode]) {
      response.hexcode = this.data.SHORTCODE_TO_HEXCODE[response.shortcode];
      return response;
    }

    return null;
  };

  _proto.matchUnicode = function matchUnicode(string) {
    var response = this.doMatch(string, _emojibaseRegex.default, function (matches) {
      return {
        unicode: matches[0]
      };
    }, true);

    if (response && response.unicode && this.data && this.data.UNICODE_TO_HEXCODE[response.unicode]) {
      response.hexcode = this.data.UNICODE_TO_HEXCODE[response.unicode];
      return response;
    }

    return null;
  };

  _proto.onBeforeParse = function onBeforeParse(content, props) {
    if (props.emojiSource) {
      this.data = _EmojiDataManager.default.getInstance(props.emojiSource.locale);
    } else if ("production" !== process.env.NODE_ENV) {
      throw new Error('Missing emoji source data. Have you loaded with the `useEmojiData` hook and passed the `emojiSource` prop?');
    }

    return content;
  };

  _proto.onAfterParse = function onAfterParse(content, props) {
    if (content.length === 0) {
      return content;
    }

    var _this$options$enlarge = this.options.enlargeThreshold,
        enlargeThreshold = _this$options$enlarge === void 0 ? 1 : _this$options$enlarge;
    var valid = false;
    var count = 0;

    for (var i = 0, item = null; i < content.length; i += 1) {
      item = content[i];

      if (typeof item === 'string') {
        if (!item.match(/^\s+$/)) {
          valid = false;
          break;
        }
      } else if (_react.default.isValidElement(item)) {
        if (item && item.type === _Emoji.default) {
          count += 1;
          valid = true;

          if (count > enlargeThreshold) {
            valid = false;
            break;
          }
        } else {
          valid = false;
          break;
        }
      } else {
        valid = false;
        break;
      }
    }

    if (!valid) {
      return content;
    }

    return content.map(function (item) {
      if (!item || typeof item === 'string') {
        return item;
      }

      var element = item;
      return _react.default.cloneElement(element, _extends({}, element.props, {
        enlargeEmoji: true
      }));
    });
  };

  return EmojiMatcher;
}(_interweave.Matcher);

exports.default = EmojiMatcher;