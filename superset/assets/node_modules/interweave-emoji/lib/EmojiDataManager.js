"use strict";

exports.__esModule = true;
exports.resetInstances = resetInstances;
exports.default = void 0;

var _emojibase = require("emojibase");

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var instances = new Map();

function resetInstances() {
  if ("production" !== process.env.NODE_ENV) {
    instances.clear();
  }
}

var EmojiDataManager = function () {
  function EmojiDataManager(locale) {
    if (locale === void 0) {
      locale = 'en';
    }

    _defineProperty(this, "EMOJIS", {});

    _defineProperty(this, "EMOTICON_TO_HEXCODE", {});

    _defineProperty(this, "SHORTCODE_TO_HEXCODE", {});

    _defineProperty(this, "UNICODE_TO_HEXCODE", {});

    _defineProperty(this, "data", []);

    _defineProperty(this, "flatData", []);

    _defineProperty(this, "locale", 'en');

    this.locale = locale;
  }

  EmojiDataManager.getInstance = function getInstance(locale) {
    if (locale === void 0) {
      locale = 'en';
    }

    if (!instances.has(locale)) {
      instances.set(locale, new EmojiDataManager(locale));
    }

    return instances.get(locale);
  };

  var _proto = EmojiDataManager.prototype;

  _proto.getData = function getData() {
    return this.data;
  };

  _proto.getFlatData = function getFlatData() {
    return this.flatData;
  };

  _proto.packageEmoji = function packageEmoji(baseEmoji) {
    var _this = this;

    var emoticon = baseEmoji.emoticon,
        hexcode = baseEmoji.hexcode,
        shortcodes = baseEmoji.shortcodes;

    var emoji = _extends({}, baseEmoji, {
      canonical_shortcodes: [],
      primary_shortcode: '',
      skins: [],
      unicode: ''
    });

    if (!emoji.unicode) {
      emoji.unicode = emoji.text && emoji.type === _emojibase.TEXT ? emoji.text : emoji.emoji;
    }

    emoji.canonical_shortcodes = shortcodes.map(function (code) {
      return ":" + code + ":";
    });
    emoji.primary_shortcode = emoji.canonical_shortcodes[0];
    emoji.canonical_shortcodes.forEach(function (shortcode) {
      _this.SHORTCODE_TO_HEXCODE[shortcode] = hexcode;
    });

    if (emoticon) {
      (0, _emojibase.generateEmoticonPermutations)(emoticon, _emojibase.EMOTICON_OPTIONS[emoticon]).forEach(function (emo) {
        _this.EMOTICON_TO_HEXCODE[emo] = hexcode;
      });
    }

    this.UNICODE_TO_HEXCODE[(0, _emojibase.fromCodepointToUnicode)((0, _emojibase.fromHexcodeToCodepoint)(hexcode))] = hexcode;

    if (emoji.emoji) {
      this.UNICODE_TO_HEXCODE[emoji.emoji] = hexcode;
    }

    if (emoji.text) {
      this.UNICODE_TO_HEXCODE[emoji.text] = hexcode;
    }

    this.EMOJIS[hexcode] = emoji;

    if (baseEmoji.skins) {
      emoji.skins = baseEmoji.skins.map(function (skinEmoji) {
        return _this.packageEmoji(skinEmoji);
      });
    }

    return emoji;
  };

  _proto.parseEmojiData = function parseEmojiData(data) {
    var _this2 = this;

    data.forEach(function (emoji) {
      var packagedEmoji = _this2.packageEmoji(emoji);

      _this2.data.push(packagedEmoji);

      _this2.flatData.push(packagedEmoji);

      if (packagedEmoji.skins) {
        packagedEmoji.skins.forEach(function (skin) {
          _this2.flatData.push(_this2.packageEmoji(skin));
        });
      }
    });
    return this.data;
  };

  return EmojiDataManager;
}();

exports.default = EmojiDataManager;