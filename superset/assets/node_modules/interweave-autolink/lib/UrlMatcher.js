"use strict";

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _interweave = require("interweave");

var _Url = _interopRequireDefault(require("./Url"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var UrlMatcher = function (_Matcher) {
  _inheritsLoose(UrlMatcher, _Matcher);

  function UrlMatcher(name, options, factory) {
    return _Matcher.call(this, name, _extends({
      customTLDs: [],
      validateTLD: true
    }, options), factory) || this;
  }

  var _proto = UrlMatcher.prototype;

  _proto.replaceWith = function replaceWith(children, props) {
    return _react.default.createElement(_Url.default, props, children);
  };

  _proto.asTag = function asTag() {
    return 'a';
  };

  _proto.match = function match(string) {
    var response = this.doMatch(string, _constants.URL_PATTERN, this.handleMatches);

    if (response && response.match.match(_constants.EMAIL_DISTINCT_PATTERN)) {
      response.valid = false;
    }

    if (response && this.options.validateTLD) {
      var _ref = response.urlParts,
          host = _ref.host;

      var validList = _constants.TOP_LEVEL_TLDS.concat(this.options.customTLDs || []);

      var tld = host.slice(host.lastIndexOf('.') + 1).toLowerCase();

      if (!validList.includes(tld)) {
        return null;
      }
    }

    return response;
  };

  _proto.handleMatches = function handleMatches(matches) {
    return {
      url: matches[0],
      urlParts: {
        auth: matches[2] ? matches[2].slice(0, -1) : '',
        fragment: matches[7] || '',
        host: matches[3],
        path: matches[5] || '',
        port: matches[4] ? matches[4] : '',
        query: matches[6] || '',
        scheme: matches[1] ? matches[1].replace('://', '') : 'http'
      }
    };
  };

  return UrlMatcher;
}(_interweave.Matcher);

exports.default = UrlMatcher;