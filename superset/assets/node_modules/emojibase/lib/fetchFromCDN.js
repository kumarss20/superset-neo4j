"use strict";

exports.__esModule = true;
exports.default = fetchFromCDN;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function fetchFromCDN(path, version, options) {
  if (version === void 0) {
    version = 'latest';
  }

  if (options === void 0) {
    options = {};
  }

  if ("production" !== process.env.NODE_ENV) {
    if (!path || path.slice(-5) !== '.json') {
      throw new Error('A valid JSON dataset is required to fetch.');
    }

    if (!version) {
      throw new Error('A valid release version is required.');
    }
  }

  var _options = options,
      _options$local = _options.local,
      local = _options$local === void 0 ? false : _options$local,
      opts = _objectWithoutPropertiesLoose(_options, ["local"]);

  var storage = local ? localStorage : sessionStorage;
  var cacheKey = "emojibase/" + version + "/" + path;
  var cachedData = storage.getItem(cacheKey);

  if (cachedData) {
    try {
      return Promise.resolve(JSON.parse(cachedData));
    } catch (error) {
      return Promise.resolve([]);
    }
  }

  return fetch("https://cdn.jsdelivr.net/npm/emojibase-data@" + version + "/" + path, _extends({
    credentials: 'omit',
    mode: 'cors',
    redirect: 'error'
  }, opts)).then(function (response) {
    if (!response.ok) {
      throw new Error('Failed to load Emojibase dataset.');
    }

    return response.json();
  }).then(function (data) {
    try {
      storage.setItem(cacheKey, JSON.stringify(data));
    } catch (error) {}

    return data;
  });
}