import _pt from "prop-types";

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import debounce from 'lodash/debounce';
import { useEmojiData } from 'interweave-emoji';
import EmojiList from './EmojiList';
import SkinTonePalette from './SkinTonePalette';
import GroupTabs from './GroupTabs';
import PreviewBar from './PreviewBar';
import SearchBar from './SearchBar';
import Context from './Context';
import { GROUPS, GROUP_KEY_COMMONLY_USED, GROUP_KEY_SMILEYS_EMOTION, GROUP_KEY_SEARCH_RESULTS, GROUP_KEY_NONE, SKIN_TONES, SKIN_KEY_NONE, KEY_COMMONLY_USED, KEY_SKIN_TONE, COMMON_MODE_RECENT, COMMON_MODE_FREQUENT, CONTEXT_CLASSNAMES, CONTEXT_MESSAGES, SEARCH_THROTTLE, GROUP_KEY_VARIATIONS } from './constants';
var SKIN_MODIFIER_PATTERN = /1F3FB|1F3FC|1F3FD|1F3FE|1F3FF/g;
export var InternalPicker = function (_React$PureComponent) {
  _inheritsLoose(InternalPicker, _React$PureComponent);

  function InternalPicker(props) {
    var _this;

    _this = _React$PureComponent.call(this, props) || this;

    _defineProperty(_assertThisInitialized(_this), "allowList", void 0);

    _defineProperty(_assertThisInitialized(_this), "blockList", void 0);

    _defineProperty(_assertThisInitialized(_this), "handleClear", function () {
      if (_this.state.activeGroup === GROUP_KEY_VARIATIONS) {
        _this.setUpdatedState({
          activeGroup: _this.state.searchQuery ? GROUP_KEY_SEARCH_RESULTS : GROUP_KEY_SMILEYS_EMOTION
        }, true);
      } else {
        _this.setUpdatedState({
          commonEmojis: []
        });

        localStorage.removeItem(KEY_COMMONLY_USED);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleEnterEmoji", function (emoji, event) {
      _this.setUpdatedState({
        activeEmoji: emoji
      });

      _this.props.onHoverEmoji(emoji, event);
    });

    _defineProperty(_assertThisInitialized(_this), "handleKeyUp", function (event) {
      var _this$props$columnCou = _this.props.columnCount,
          columnCount = _this$props$columnCou === void 0 ? 10 : _this$props$columnCou;
      var _this$state = _this.state,
          activeEmoji = _this$state.activeEmoji,
          activeEmojiIndex = _this$state.activeEmojiIndex,
          emojis = _this$state.emojis,
          searchQuery = _this$state.searchQuery;

      if (!searchQuery) {
        return;
      }

      if (event.key === 'Escape') {
        event.preventDefault();

        _this.handleSearch('', event);
      } else if (event.key === 'Enter') {
        event.preventDefault();

        if (activeEmoji) {
          _this.handleSelectEmoji(activeEmoji, event);
        }
      } else {
        event.preventDefault();
        var nextIndex = -1;

        switch (event.key) {
          case 'ArrowLeft':
            nextIndex = activeEmojiIndex - 1;
            break;

          case 'ArrowRight':
            nextIndex = activeEmojiIndex + 1;
            break;

          case 'ArrowUp':
            nextIndex = activeEmojiIndex - columnCount;
            break;

          case 'ArrowDown':
            nextIndex = activeEmojiIndex + columnCount;
            break;

          default:
            return;
        }

        if (nextIndex >= 0 && nextIndex < emojis.length) {
          _this.setUpdatedState({
            activeEmojiIndex: nextIndex
          });

          _this.handleEnterEmoji(emojis[nextIndex], event);
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleLeaveEmoji", function () {
      _this.setUpdatedState({
        activeEmoji: null
      });
    });

    _defineProperty(_assertThisInitialized(_this), "handleScrollGroup", function (group) {
      _this.setUpdatedState({
        activeGroup: group,
        scrollToGroup: ''
      });

      _this.props.onScrollGroup(group);
    });

    _defineProperty(_assertThisInitialized(_this), "handleSearch", function (query, event) {
      _this.setState({
        searchQuery: query
      });

      _this.handleSearchDebounced(query);

      _this.props.onSearch(query, event);
    });

    _defineProperty(_assertThisInitialized(_this), "handleSearchDebounced", debounce(function (query) {
      _this.setUpdatedState({
        searchQuery: query
      });
    }, SEARCH_THROTTLE));

    _defineProperty(_assertThisInitialized(_this), "handleSelectEmoji", function (emoji, event) {
      _this.addCommonEmoji(emoji);

      if (event.shiftKey && emoji.skins && emoji.skins.length > 0) {
        var _groupedEmojis;

        _this.setState({
          activeEmoji: emoji,
          activeEmojiIndex: 0,
          activeGroup: GROUP_KEY_VARIATIONS,
          emojis: emoji.skins,
          groupedEmojis: (_groupedEmojis = {}, _groupedEmojis[GROUP_KEY_VARIATIONS] = {
            emojis: emoji.skins,
            group: GROUP_KEY_VARIATIONS
          }, _groupedEmojis),
          scrollToGroup: GROUP_KEY_VARIATIONS
        });
      } else {
        _this.props.onSelectEmoji(emoji, event);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleSelectGroup", function (group, event) {
      _this.setUpdatedState({
        activeGroup: group,
        scrollToGroup: group
      });

      _this.props.onSelectGroup(group, event);
    });

    _defineProperty(_assertThisInitialized(_this), "handleSelectSkinTone", function (skinTone, event) {
      _this.setUpdatedState({
        activeSkinTone: skinTone
      });

      try {
        localStorage.setItem(KEY_SKIN_TONE, skinTone);
      } catch (error) {}

      _this.props.onSelectSkinTone(skinTone, event);
    });

    var _ref = props,
        blockList = _ref.blockList,
        classNames = _ref.classNames,
        defaultSkinTone = _ref.defaultSkinTone,
        messages = _ref.messages,
        allowList = _ref.allowList;
    _this.allowList = _this.generateAllowBlockMap(allowList);
    _this.blockList = _this.generateAllowBlockMap(blockList);
    var _searchQuery = '';

    var commonEmojis = _this.generateCommonEmojis(_this.getCommonEmojisFromStorage());

    var activeGroup = _this.getActiveGroup(commonEmojis.length > 0);

    var activeSkinTone = _this.getSkinToneFromStorage() || defaultSkinTone;

    var _emojis = _this.generateEmojis(activeSkinTone, _searchQuery);

    var groupedEmojis = _this.groupEmojis(_emojis, commonEmojis, _searchQuery);

    _this.state = {
      activeEmoji: null,
      activeEmojiIndex: -1,
      activeGroup: activeGroup,
      activeSkinTone: activeSkinTone,
      commonEmojis: commonEmojis,
      context: {
        classNames: _extends({}, CONTEXT_CLASSNAMES, {}, classNames),
        emojiLargeSize: props.emojiLargeSize,
        emojiPadding: props.emojiPadding,
        emojiPath: props.emojiPath,
        emojiSize: props.emojiSize,
        emojiSource: props.emojiSource,
        messages: _extends({}, CONTEXT_MESSAGES, {}, messages)
      },
      emojis: _emojis,
      groupedEmojis: groupedEmojis,
      scrollToGroup: activeGroup,
      searchQuery: _searchQuery
    };
    return _this;
  }

  var _proto = InternalPicker.prototype;

  _proto.addCommonEmoji = function addCommonEmoji(emoji) {
    var _this$props = this.props,
        commonMode = _this$props.commonMode,
        disableCommonlyUsed = _this$props.disableCommonlyUsed,
        maxCommonlyUsed = _this$props.maxCommonlyUsed;
    var hexcode = emoji.hexcode;

    if (disableCommonlyUsed) {
      return;
    }

    var commonEmojis = this.getCommonEmojisFromStorage();
    var currentIndex = commonEmojis.findIndex(function (common) {
      return common.hexcode === hexcode;
    });

    if (currentIndex === -1) {
      commonEmojis.unshift({
        count: 1,
        hexcode: hexcode
      });
    }

    if (commonMode === COMMON_MODE_RECENT) {
      if (currentIndex >= 1) {
        var _commonEmojis$splice = commonEmojis.splice(currentIndex, 1),
            common = _commonEmojis$splice[0];

        commonEmojis.unshift({
          count: common.count + 1,
          hexcode: hexcode
        });
      }
    } else if (commonMode === COMMON_MODE_FREQUENT) {
      if (currentIndex >= 0) {
        commonEmojis[currentIndex].count += 1;
      }

      commonEmojis.sort(function (a, b) {
        return b.count - a.count;
      });
    }

    try {
      localStorage.setItem(KEY_COMMONLY_USED, JSON.stringify(commonEmojis.slice(0, maxCommonlyUsed)));
    } catch (error) {}

    this.setUpdatedState({
      commonEmojis: this.generateCommonEmojis(commonEmojis)
    });
  };

  _proto.filterOrSearch = function filterOrSearch(emoji, searchQuery) {
    var _ref2 = this.props,
        blockList = _ref2.blockList,
        maxEmojiVersion = _ref2.maxEmojiVersion,
        allowList = _ref2.allowList;

    if (blockList.length > 0 && this.blockList[emoji.hexcode] || allowList.length > 0 && !this.allowList[emoji.hexcode]) {
      return false;
    }

    if (emoji.version && emoji.version > maxEmojiVersion) {
      return false;
    }

    if (!searchQuery) {
      return true;
    }

    var lookups = [];

    if (emoji.canonical_shortcodes) {
      lookups.push.apply(lookups, emoji.canonical_shortcodes);
    }

    if (emoji.tags) {
      lookups.push.apply(lookups, emoji.tags);
    }

    if (emoji.annotation) {
      lookups.push(emoji.annotation);
    }

    if (emoji.emoticon) {
      lookups.push(emoji.emoticon);
    }

    var haystack = lookups.join(' ').toLowerCase();
    return searchQuery.toLowerCase().split(' ').some(function (needle) {
      return haystack.includes(needle);
    });
  };

  _proto.generateEmojis = function generateEmojis(skinTone, searchQuery) {
    var _this2 = this;

    return this.props.emojis.filter(function (emoji) {
      return _this2.filterOrSearch(emoji, searchQuery);
    }).map(function (emoji) {
      return _this2.getSkinnedEmoji(emoji, skinTone);
    });
  };

  _proto.generateAllowBlockMap = function generateAllowBlockMap(list) {
    var map = {};
    list.forEach(function (hexcode) {
      if ("production" !== process.env.NODE_ENV) {
        if (hexcode.match(SKIN_MODIFIER_PATTERN)) {
          console.warn("Hexcode with a skin modifier has been detected: " + hexcode, 'Emojis without skin modifiers are required for allow/block lists.');
        }
      }

      map[hexcode] = true;
    });
    return map;
  };

  _proto.generateCommonEmojis = function generateCommonEmojis(commonEmojis) {
    if (this.props.disableCommonlyUsed) {
      return [];
    }

    var data = this.props.emojiData;
    return commonEmojis.map(function (emoji) {
      return data.EMOJIS[emoji.hexcode];
    }).filter(Boolean);
  };

  _proto.getActiveGroup = function getActiveGroup(hasCommon) {
    var _this$props2 = this.props,
        defaultGroup = _this$props2.defaultGroup,
        disableGroups = _this$props2.disableGroups;
    var group = defaultGroup;

    if (group === GROUP_KEY_COMMONLY_USED) {
      if (hasCommon) {
        return group;
      }

      group = GROUP_KEY_SMILEYS_EMOTION;
    }

    return disableGroups ? GROUP_KEY_NONE : group;
  };

  _proto.getCommonEmojisFromStorage = function getCommonEmojisFromStorage() {
    if (this.props.disableCommonlyUsed) {
      return [];
    }

    var common = localStorage.getItem(KEY_COMMONLY_USED);
    return common ? JSON.parse(common) : [];
  };

  _proto.getSkinnedEmoji = function getSkinnedEmoji(emoji, skinTone) {
    if (skinTone === SKIN_KEY_NONE || !emoji.skins) {
      return emoji;
    }

    var toneIndex = SKIN_TONES.findIndex(function (tone) {
      return tone === skinTone;
    });
    var skinnedEmoji = (emoji.skins || []).find(function (skin) {
      return !!skin.tone && (skin.tone === toneIndex || Array.isArray(skin.tone) && skin.tone.includes(toneIndex));
    });
    return skinnedEmoji || emoji;
  };

  _proto.getSkinToneFromStorage = function getSkinToneFromStorage() {
    var tone = localStorage.getItem(KEY_SKIN_TONE);

    if (tone) {
      return tone;
    }

    return null;
  };

  _proto.groupEmojis = function groupEmojis(emojis, commonEmojis, searchQuery) {
    var disableGroups = this.props.disableGroups;
    var groups = {};

    if (!searchQuery && commonEmojis.length > 0) {
      groups[GROUP_KEY_COMMONLY_USED] = {
        emojis: commonEmojis,
        group: GROUP_KEY_COMMONLY_USED
      };
    }

    emojis.forEach(function (emoji) {
      var group = GROUP_KEY_NONE;

      if (searchQuery) {
        group = GROUP_KEY_SEARCH_RESULTS;
      } else if (!disableGroups && typeof emoji.group !== 'undefined') {
        group = GROUPS[emoji.group];
      }

      if (!group) {
        return;
      }

      if (groups[group]) {
        groups[group].emojis.push(emoji);
      } else {
        groups[group] = {
          emojis: [emoji],
          group: group
        };
      }
    });
    Object.keys(groups).forEach(function (group) {
      if (group !== GROUP_KEY_COMMONLY_USED) {
        groups[group].emojis.sort(function (a, b) {
          return (a.order || 0) - (b.order || 0);
        });
      }

      if (groups[group].emojis.length === 0) {
        delete groups[group];
      }
    });
    return groups;
  };

  _proto.setUpdatedState = function setUpdatedState(nextState, forceRebuild) {
    var _this3 = this;

    if (forceRebuild === void 0) {
      forceRebuild = false;
    }

    this.setState(function (prevState) {
      var state = _extends({}, prevState, {}, nextState);

      var activeGroup = _this3.getActiveGroup(state.commonEmojis.length > 0);

      var rebuildEmojis = false;

      if ('commonEmojis' in nextState) {
        rebuildEmojis = true;

        if (state.commonEmojis.length === 0) {
          state.activeGroup = activeGroup;
        }
      }

      if ('activeGroup' in nextState) {
        if (state.searchQuery) {
          state.searchQuery = '';
          rebuildEmojis = true;
        }
      }

      if ('activeSkinTone' in nextState) {
        rebuildEmojis = true;
      }

      if ('searchQuery' in nextState) {
        rebuildEmojis = true;
        state.activeGroup = state.searchQuery ? GROUP_KEY_SEARCH_RESULTS : activeGroup;
        state.scrollToGroup = state.searchQuery ? GROUP_KEY_SEARCH_RESULTS : activeGroup;
      }

      if (rebuildEmojis || forceRebuild) {
        state.emojis = _this3.generateEmojis(state.activeSkinTone, state.searchQuery);
        state.groupedEmojis = _this3.groupEmojis(state.emojis, state.commonEmojis, state.searchQuery);
        var hasResults = state.searchQuery && state.emojis.length > 0;
        state.activeEmoji = hasResults ? state.emojis[0] : null;
        state.activeEmojiIndex = hasResults ? 0 : -1;
      }

      return state;
    });
  };

  _proto.render = function render() {
    var _ref3 = this.props,
        autoFocus = _ref3.autoFocus,
        clearIcon = _ref3.clearIcon,
        columnCount = _ref3.columnCount,
        commonMode = _ref3.commonMode,
        disableGroups = _ref3.disableGroups,
        disablePreview = _ref3.disablePreview,
        disableSearch = _ref3.disableSearch,
        disableSkinTones = _ref3.disableSkinTones,
        displayOrder = _ref3.displayOrder,
        groupIcons = _ref3.groupIcons,
        hideEmoticon = _ref3.hideEmoticon,
        hideGroupHeaders = _ref3.hideGroupHeaders,
        hideShortcodes = _ref3.hideShortcodes,
        noPreview = _ref3.noPreview,
        noResults = _ref3.noResults,
        rowCount = _ref3.rowCount,
        skinIcons = _ref3.skinIcons,
        stickyGroupHeader = _ref3.stickyGroupHeader,
        virtual = _ref3.virtual,
        onScroll = _ref3.onScroll;
    var _this$state2 = this.state,
        activeEmoji = _this$state2.activeEmoji,
        activeGroup = _this$state2.activeGroup,
        activeSkinTone = _this$state2.activeSkinTone,
        commonEmojis = _this$state2.commonEmojis,
        context = _this$state2.context,
        groupedEmojis = _this$state2.groupedEmojis,
        scrollToGroup = _this$state2.scrollToGroup,
        searchQuery = _this$state2.searchQuery;
    var skinTones = disableSkinTones ? null : React.createElement(SkinTonePalette, {
      key: "skin-tones",
      activeSkinTone: activeSkinTone,
      icons: skinIcons,
      onSelect: this.handleSelectSkinTone
    });
    var components = {
      emojis: React.createElement(EmojiList, _extends({
        key: "emojis"
      }, virtual, {
        activeEmoji: activeEmoji,
        activeGroup: activeGroup,
        clearIcon: clearIcon,
        columnCount: columnCount,
        commonMode: commonMode,
        groupedEmojis: groupedEmojis,
        hideGroupHeaders: hideGroupHeaders,
        noResults: noResults,
        rowCount: rowCount,
        scrollToGroup: scrollToGroup,
        skinTonePalette: displayOrder.includes('skin-tones') ? null : skinTones,
        stickyGroupHeader: stickyGroupHeader,
        onClear: this.handleClear,
        onEnterEmoji: this.handleEnterEmoji,
        onLeaveEmoji: this.handleLeaveEmoji,
        onScroll: onScroll,
        onScrollGroup: this.handleScrollGroup,
        onSelectEmoji: this.handleSelectEmoji
      })),
      groups: disableGroups ? null : React.createElement(GroupTabs, {
        key: "groups",
        activeGroup: activeGroup,
        commonEmojis: commonEmojis,
        commonMode: commonMode,
        icons: groupIcons,
        onSelect: this.handleSelectGroup
      }),
      preview: disablePreview ? null : React.createElement(PreviewBar, {
        key: "preview",
        emoji: activeEmoji,
        hideEmoticon: hideEmoticon,
        hideShortcodes: hideShortcodes,
        noPreview: noPreview
      }),
      search: disableSearch ? null : React.createElement(SearchBar, {
        key: "search",
        autoFocus: autoFocus,
        searchQuery: searchQuery,
        onChange: this.handleSearch,
        onKeyUp: this.handleKeyUp
      }),
      'skin-tones': skinTones
    };
    return React.createElement(Context.Provider, {
      value: context
    }, React.createElement("div", {
      className: context.classNames.picker
    }, displayOrder.map(function (key) {
      return components[key];
    })));
  };

  return InternalPicker;
}(React.PureComponent);

_defineProperty(InternalPicker, "propTypes", {
  allowList: _pt.arrayOf(_pt.any),
  autoFocus: _pt.bool,
  blockList: _pt.arrayOf(_pt.any),
  classNames: _pt.objectOf(_pt.string),
  clearIcon: _pt.node,
  columnCount: _pt.number,
  commonMode: _pt.any,
  defaultGroup: _pt.any,
  defaultSkinTone: _pt.any,
  disableCommonlyUsed: _pt.bool,
  disableGroups: _pt.bool,
  disablePreview: _pt.bool,
  disableSearch: _pt.bool,
  disableSkinTones: _pt.bool,
  displayOrder: _pt.arrayOf(_pt.any),
  emojiLargeSize: _pt.number.isRequired,
  emojiPadding: _pt.number,
  emojiPath: _pt.any.isRequired,
  emojiSize: _pt.number.isRequired,
  groupIcons: _pt.objectOf(_pt.node),
  hideEmoticon: _pt.bool,
  hideGroupHeaders: _pt.bool,
  hideShortcodes: _pt.bool,
  maxCommonlyUsed: _pt.number,
  maxEmojiVersion: _pt.number
});

_defineProperty(InternalPicker, "defaultProps", {
  allowList: [],
  autoFocus: false,
  blockList: [],
  classNames: {},
  clearIcon: null,
  columnCount: 10,
  commonMode: COMMON_MODE_RECENT,
  defaultGroup: GROUP_KEY_COMMONLY_USED,
  defaultSkinTone: SKIN_KEY_NONE,
  disableCommonlyUsed: false,
  disableGroups: false,
  disablePreview: false,
  disableSearch: false,
  disableSkinTones: false,
  displayOrder: ['preview', 'emojis', 'groups', 'search'],
  emojiPadding: 0,
  groupIcons: {},
  hideEmoticon: false,
  hideGroupHeaders: false,
  hideShortcodes: false,
  maxCommonlyUsed: 30,
  maxEmojiVersion: 5,
  messages: {},
  noPreview: null,
  noResults: null,
  onHoverEmoji: function onHoverEmoji() {},
  onScroll: function onScroll() {},
  onScrollGroup: function onScrollGroup() {},
  onSearch: function onSearch() {},
  onSelectEmoji: function onSelectEmoji() {},
  onSelectGroup: function onSelectGroup() {},
  onSelectSkinTone: function onSelectSkinTone() {},
  rowCount: 8,
  skinIcons: {},
  stickyGroupHeader: false,
  virtual: {}
});

export default function Picker(_ref4) {
  var compact = _ref4.compact,
      locale = _ref4.locale,
      throwErrors = _ref4.throwErrors,
      version = _ref4.version,
      props = _objectWithoutPropertiesLoose(_ref4, ["compact", "locale", "throwErrors", "version"]);

  var _useEmojiData = useEmojiData({
    compact: compact,
    locale: locale,
    throwErrors: throwErrors,
    version: version
  }),
      emojis = _useEmojiData[0],
      source = _useEmojiData[1],
      data = _useEmojiData[2];

  if (emojis.length === 0) {
    return null;
  }

  return React.createElement(InternalPicker, _extends({}, props, {
    emojis: emojis,
    emojiData: data,
    emojiSource: source
  }));
}
Picker.propTypes = {
  allowList: _pt.arrayOf(_pt.any),
  autoFocus: _pt.bool,
  blockList: _pt.arrayOf(_pt.any),
  classNames: _pt.objectOf(_pt.string),
  clearIcon: _pt.node,
  columnCount: _pt.number,
  commonMode: _pt.any,
  defaultGroup: _pt.any,
  defaultSkinTone: _pt.any,
  disableCommonlyUsed: _pt.bool,
  disableGroups: _pt.bool,
  disablePreview: _pt.bool,
  disableSearch: _pt.bool,
  disableSkinTones: _pt.bool,
  displayOrder: _pt.arrayOf(_pt.any),
  emojiLargeSize: _pt.number.isRequired,
  emojiPadding: _pt.number,
  emojiPath: _pt.any.isRequired,
  emojiSize: _pt.number.isRequired,
  groupIcons: _pt.objectOf(_pt.node),
  hideEmoticon: _pt.bool,
  hideGroupHeaders: _pt.bool,
  hideShortcodes: _pt.bool,
  maxCommonlyUsed: _pt.number,
  maxEmojiVersion: _pt.number
};