import React from 'react';
import { UseEmojiDataOptions, CanonicalEmoji, Path, Source, EmojiDataManager } from 'interweave-emoji';
import { Hexcode } from 'emojibase';
import { CommonEmoji, CommonMode, Context as EmojiContext, DisplayOrder, GroupKey, SkinToneKey, GroupEmojiMap } from './types';
export interface AllowBlockMap {
    [hexcode: string]: boolean;
}
export interface PickerProps {
    /** List of emoji hexcodes to only show. */
    allowList?: Hexcode[];
    /** Focus the search bar on mount. */
    autoFocus?: boolean;
    /** List of emoji hexcodes to hide. */
    blockList?: Hexcode[];
    /** Mapping of custom CSS class names. */
    classNames?: {
        [key: string]: string;
    };
    /** Icon to display within the clear commonly used button. Omit the icon to hide the button. */
    clearIcon?: React.ReactNode;
    /** Number of emojis to display horizontally. */
    columnCount?: number;
    /** Type of commonly used mode. */
    commonMode?: CommonMode;
    /** Group to select by default. */
    defaultGroup?: GroupKey;
    /** Skin tone to select by default (if not found in local storage). */
    defaultSkinTone?: SkinToneKey;
    /** Disable commonly used functionality. */
    disableCommonlyUsed?: boolean;
    /** Disable and hide group tabs. */
    disableGroups?: boolean;
    /** Disable and hide preview bar. */
    disablePreview?: boolean;
    /** Disable and hide search bar. */
    disableSearch?: boolean;
    /** Disable and hide skin tone palette bar. */
    disableSkinTones?: boolean;
    /** Order to render components in. */
    displayOrder?: DisplayOrder[];
    /** Size of the emoji within the preview bar. */
    emojiLargeSize: number;
    /** Padding around each emoji. */
    emojiPadding?: number;
    /** Path to an SVG/PNG. Accepts a string or a callback that is passed the hexcode. */
    emojiPath: Path;
    /** Pixel size of emoji within the list. */
    emojiSize: number;
    /** Mapping of custom icons for each group tab. */
    groupIcons?: {
        [key: string]: React.ReactNode;
    };
    /** Hide emoticons within the preview bar. */
    hideEmoticon?: boolean;
    /** Hide group headers within the list. */
    hideGroupHeaders?: boolean;
    /** Hide shortcodes within the preview bar. */
    hideShortcodes?: boolean;
    /** Max number of commonly used to store. */
    maxCommonlyUsed?: number;
    /** Max official emoji release version to support. */
    maxEmojiVersion?: number;
    /** Mapping of custom translation messages. */
    messages?: {
        [key: string]: string;
    };
    /** Content to render by default in the preview bar. */
    noPreview?: React.ReactNode;
    /** Content to render when there are no search results. */
    noResults?: React.ReactNode;
    /** Callback fired when hovering an emoji. */
    onHoverEmoji?: (emoji: CanonicalEmoji, event: React.MouseEvent<HTMLButtonElement>) => void;
    /** Callback fired when scrolling the emoji list. */
    onScroll?: () => void;
    /** Callback fired when a new group is scrolled into view. */
    onScrollGroup?: (group: GroupKey) => void;
    /** Callback fired when typing in the search field. */
    onSearch?: (query: string, event: React.ChangeEvent<HTMLInputElement>) => void;
    /** Callback fired when clicking on an emoji. */
    onSelectEmoji?: (emoji: CanonicalEmoji, event: React.MouseEvent<HTMLButtonElement>) => void;
    /** Callback fired when clicking a group tab. */
    onSelectGroup?: (group: GroupKey, event: React.MouseEvent<HTMLButtonElement>) => void;
    /** Callback fired when clicking a skin tone. */
    onSelectSkinTone?: (skinTone: SkinToneKey, event: React.MouseEvent<HTMLButtonElement>) => void;
    /** Number of emoji rows to display vertically. */
    rowCount?: number;
    /** Mapping of custom icons for each skin tone. */
    skinIcons?: {
        [key: string]: React.ReactNode;
    };
    /** Sticky the active group header to the top of the emoji list. */
    stickyGroupHeader?: boolean;
    /** Custom props to pass to react-window list component. */
    virtual?: {
        columnPadding?: number;
        rowPadding?: number;
    };
}
export interface InternalPickerProps extends PickerProps {
    /** List of all emojis. */
    emojis: CanonicalEmoji[];
    /** Data manager instance. */
    emojiData: EmojiDataManager;
    /** Emoji data source metadata. */
    emojiSource: Source;
}
export interface InternalPickerState {
    /** Emoji to display in the preview. */
    activeEmoji: CanonicalEmoji | null;
    /** Index for the highlighted emoji within search results. */
    activeEmojiIndex: number;
    /** Currently selected group tab. */
    activeGroup: GroupKey;
    /** Currently selected skin tone. */
    activeSkinTone: SkinToneKey;
    /** List of emoji hexcodes most commonly used. */
    commonEmojis: CanonicalEmoji[];
    /** React context. */
    context: EmojiContext;
    /** List of all emojis with search filtering applied. */
    emojis: CanonicalEmoji[];
    /** Filtered emojis grouped by group number. */
    groupedEmojis: GroupEmojiMap;
    /** Group to scroll to on render. */
    scrollToGroup: GroupKey | '';
    /** Current search query. */
    searchQuery: string;
}
export declare class InternalPicker extends React.PureComponent<InternalPickerProps, InternalPickerState> {
    static defaultProps: Partial<InternalPickerProps>;
    allowList: AllowBlockMap;
    blockList: AllowBlockMap;
    constructor(props: InternalPickerProps);
    /**
     * Add a common emoji to local storage and update the current state.
     */
    addCommonEmoji(emoji: CanonicalEmoji): void;
    /**
     * Filter the dataset with the search query against a set of emoji properties.
     */
    filterOrSearch(emoji: CanonicalEmoji, searchQuery: string): boolean;
    /**
     * Return the list of emojis filtered with the search query if applicable,
     * and with skin tone applied if set.
     */
    generateEmojis(skinTone: SkinToneKey, searchQuery: string): CanonicalEmoji[];
    /**
     * Convert the `blockList` or `allowList` prop to a map for quicker lookups.
     */
    generateAllowBlockMap(list: string[]): AllowBlockMap;
    /**
     * We only store the hexcode character for commonly used emojis,
     * so we need to rebuild the list with full emoji objects.
     */
    generateCommonEmojis(commonEmojis: CommonEmoji[]): CanonicalEmoji[];
    /**
     * Return the default group while handling commonly used scenarios.
     */
    getActiveGroup(hasCommon: boolean): GroupKey;
    /**
     * Return the commonly used emojis from local storage.
     */
    getCommonEmojisFromStorage(): CommonEmoji[];
    /**
     * Return an emoji with skin tone if the active skin tone is set,
     * otherwise return the default skin tone (yellow).
     */
    getSkinnedEmoji(emoji: CanonicalEmoji, skinTone: SkinToneKey): CanonicalEmoji;
    /**
     * Return the user's favorite skin tone from local storage.
     */
    getSkinToneFromStorage(): SkinToneKey | null;
    /**
     * Partition the dataset into multiple arrays based on the group they belong to.
     */
    groupEmojis(emojis: CanonicalEmoji[], commonEmojis: CanonicalEmoji[], searchQuery: string): GroupEmojiMap;
    /**
     * Triggered when common emoji cache or variation window is cleared.
     */
    private handleClear;
    /**
     * Triggered when the mouse hovers an emoji.
     */
    private handleEnterEmoji;
    /**
     * Triggered when keyboard changes occur.
     */
    private handleKeyUp;
    /**
     * Triggered when the mouse no longer hovers an emoji.
     */
    private handleLeaveEmoji;
    /**
     * Triggered when a group is scrolled into view.
     */
    private handleScrollGroup;
    /**
     * Triggered when the search input field value changes.
     */
    private handleSearch;
    private handleSearchDebounced;
    /**
     * Triggered when an emoji is clicked.
     */
    private handleSelectEmoji;
    /**
     * Triggered when a group tab is clicked. We should reset search and scroll position.
     */
    private handleSelectGroup;
    /**
     * Triggered when a skin tone is clicked.
     */
    private handleSelectSkinTone;
    /**
     * Catch all method to easily update the state. Will automatically handle updates
     * and branching based on values being set.
     */
    setUpdatedState(nextState: Partial<InternalPickerState>, forceRebuild?: boolean): void;
    render(): JSX.Element;
}
export default function Picker({ compact, locale, throwErrors, version, ...props }: PickerProps & UseEmojiDataOptions): JSX.Element | null;
//# sourceMappingURL=Picker.d.ts.map