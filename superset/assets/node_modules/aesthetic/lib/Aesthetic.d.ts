import CacheManager from './CacheManager';
import StyleSheetManager from './StyleSheetManager';
import UnifiedSyntax from './UnifiedSyntax';
import { AestheticOptions, ClassName, GlobalSheetDefinition, TransformOptions, SheetMap, StyleName, StyleSheet, StyleSheetDefinition, ThemeName } from './types';
export default abstract class Aesthetic<Theme extends object, NativeBlock extends object, ParsedBlock extends object | string = NativeBlock> {
    globals: {
        [themeName: string]: GlobalSheetDefinition<Theme, any>;
    };
    options: AestheticOptions;
    parents: {
        [childStyleName: string]: StyleName;
    };
    styles: {
        [styleName: string]: StyleSheetDefinition<Theme, any>;
    };
    syntax: UnifiedSyntax<NativeBlock>;
    themes: {
        [themeName: string]: Theme;
    };
    protected cacheManager: CacheManager<SheetMap<ParsedBlock>>;
    protected sheetManager: StyleSheetManager | null;
    constructor(options?: Partial<AestheticOptions>);
    /**
     * Apply and inject global styles for the current theme.
     * This should only happen once!
     */
    applyGlobalStyles(baseOptions?: TransformOptions): this;
    /**
     * Change the current theme to another registered theme.
     * This will purge all flushed global styles and regenerate new ones.
     */
    changeTheme(themeName: ThemeName): this;
    /**
     * Create and return a style sheet unique to an adapter.
     */
    createStyleSheet(styleName: StyleName, baseOptions?: TransformOptions): SheetMap<ParsedBlock>;
    /**
     * Compose and extend multiple style sheets to create 1 style sheet.
     */
    extendStyles(...styleSheets: StyleSheetDefinition<Theme, any>[]): StyleSheetDefinition<Theme, any>;
    /**
     * Register a theme by extending and merging with a previously defined theme.
     */
    extendTheme<T>(themeName: ThemeName, parentThemeName: ThemeName, theme: Partial<Theme>, globalSheet?: GlobalSheetDefinition<Theme, T>): this;
    /**
     * Flush a target component's transformed styles and inject them into the DOM.
     * If no target defined, will flush all buffered styles.
     */
    flushStyles(styleName?: StyleName): void;
    /**
     * Retrieve the component style sheet for the defined theme.
     * If the definition is a function, execute it while passing the current theme.
     */
    getStyleSheet(styleName: StyleName, themeName: ThemeName): StyleSheet;
    /**
     * Return a theme object or throw an error.
     */
    getTheme(name?: ThemeName): Theme;
    /**
     * Return true if the style object is a parsed block and not a native block.
     */
    isParsedBlock(block: NativeBlock | ParsedBlock): block is ParsedBlock;
    /**
     * Parse an Aesthetic style sheet into an adapter native style sheet.
     */
    parseStyleSheet(styleSheet: SheetMap<NativeBlock>, styleName: StyleName): SheetMap<ParsedBlock>;
    /**
     * Purge and remove all styles from the DOM for the target component.
     * If no target defined, will purge all possible styles.
     */
    purgeStyles(styleName?: StyleName): void;
    /**
     * Register a style sheet definition. Optionally extend from a parent style sheet if defined.
     */
    registerStyleSheet<T>(styleName: StyleName, styleSheet: StyleSheetDefinition<Theme, T>, extendFrom?: StyleName): this;
    /**
     * Register a theme with a set of parameters. Optionally register
     * a global style sheet to apply to the entire document.
     */
    registerTheme<T>(themeName: ThemeName, theme: Theme, globalSheet?: GlobalSheetDefinition<Theme, T>): this;
    /**
     * Transform the list of style objects to a list of CSS class names.
     */
    transformStyles(styles: (undefined | false | ClassName | NativeBlock | ParsedBlock)[], baseOptions?: TransformOptions): ClassName;
    /**
     * Transform the parsed style objects into CSS class names.
     */
    abstract transformToClassName(styles: ParsedBlock[]): ClassName;
    /**
     * Return transform options with defaults applied.
     */
    protected getPreparedTransformOptions(options?: TransformOptions): Required<TransformOptions>;
    /**
     * Return a native style sheet manager used for injecting CSS.
     */
    protected getStyleSheetManager(): StyleSheetManager;
    /**
     * Validate a style sheet or theme definition.
     */
    private validateDefinition;
}
//# sourceMappingURL=Aesthetic.d.ts.map