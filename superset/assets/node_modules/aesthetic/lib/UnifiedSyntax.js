"use strict";

exports.__esModule = true;
exports.default = exports.CLASS_NAME = exports.SELECTOR = void 0;

var _stylis = _interopRequireDefault(require("stylis"));

var _core = require("rtl-css-js/core");

var _aestheticUtils = require("aesthetic-utils");

var _Sheet = _interopRequireDefault(require("./Sheet"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SELECTOR = /^((\[[\x2Da-z\u017F\u212A]+\])|(::?[\x2Da-z\u017F\u212A]+))$/i;
exports.SELECTOR = SELECTOR;
var CLASS_NAME = /^[a-z\u017F\u212A]{1}[\x2D0-9_a-z\u017F\u212A]+$/i;
exports.CLASS_NAME = CLASS_NAME;

function rtlPlugin(context, content) {
  if (context !== 1) {
    return undefined;
  }

  var _content$split = content.split(':', 2),
      rawKey = _content$split[0],
      rawValue = _content$split[1];

  var isQuoted = rawValue.trim().startsWith("'");
  var unquotedValue = isQuoted ? rawValue.slice(1).slice(0, -1) : rawValue;

  var _convertProperty = (0, _core.convertProperty)(rawKey.trim(), unquotedValue.trim()),
      key = _convertProperty.key,
      value = _convertProperty.value;

  return key + ":" + (isQuoted ? "'" + value + "'" : value);
}

var UnifiedSyntax = function () {
  function UnifiedSyntax() {
    var _this = this;

    _defineProperty(this, "handlers", {});

    _defineProperty(this, "keyframesCount", 0);

    _defineProperty(this, "handleAnimationName", function (ruleset, value) {
      if (!value) {
        return undefined;
      }

      return (Array.isArray(value) ? value : [value]).map(function (item) {
        if (typeof item === 'string') {
          return item;
        }

        var name = item.name || "keyframe-" + (_this.keyframesCount += 1);

        _this.convertKeyframe(name, item, ruleset.root);

        return name;
      }).join(', ');
    });

    _defineProperty(this, "handleFontFamily", function (ruleset, value) {
      if (!value) {
        return undefined;
      }

      var output = new Set();
      var fontFaces = {};
      (0, _aestheticUtils.toArray)(value).forEach(function (item) {
        if (typeof item === 'string') {
          output.add(item);
          return;
        }

        var name = item.fontFamily;

        if (!name) {
          return;
        }

        output.add(name);

        if (fontFaces[name]) {
          fontFaces[name].push(item);
        } else {
          fontFaces[name] = [item];
        }
      });
      Object.keys(fontFaces).forEach(function (fontFamily) {
        _this.convertFontFaces(fontFamily, fontFaces[fontFamily], ruleset.root);
      });
      return Array.from(output).join(', ');
    });

    this.on('property:animationName', this.handleAnimationName);
    this.on('property:fontFamily', this.handleFontFamily);
  }

  var _proto = UnifiedSyntax.prototype;

  _proto.convertGlobalSheet = function convertGlobalSheet(globalSheet, options) {
    var _this2 = this;

    var sheet = new _Sheet.default(options);
    Object.keys(globalSheet).forEach(function (rule) {
      switch (rule) {
        case '@charset':
          {
            var _charset = globalSheet[rule];

            if (typeof _charset === 'string') {
              _this2.emit('charset', [sheet, _charset]);
            } else if ("production" !== process.env.NODE_ENV) {
              throw new Error('@charset must be a string.');
            }

            break;
          }

        case '@font-face':
          {
            var faces = globalSheet[rule] || {};

            if ("production" !== process.env.NODE_ENV) {
              if (!(0, _aestheticUtils.isObject)(faces)) {
                throw new Error('@font-face must be an object of font family names to font faces.');
              }
            }

            Object.keys(faces).forEach(function (fontFamily) {
              _this2.convertFontFaces(fontFamily, (0, _aestheticUtils.toArray)(faces[fontFamily]), sheet);
            });
            break;
          }

        case '@global':
          {
            var globals = globalSheet[rule] || {};

            if ("production" !== process.env.NODE_ENV) {
              if (!(0, _aestheticUtils.isObject)(globals)) {
                throw new Error('@global must be an object of selectors to ruleset objects.');
              }
            }

            Object.keys(globals).forEach(function (selector) {
              if ((0, _aestheticUtils.isObject)(globals[selector])) {
                _this2.emit('global', [sheet, selector, _this2.convertRuleset(globals[selector], sheet.createRuleset(selector))]);
              } else if ("production" !== process.env.NODE_ENV) {
                throw new Error("@global \"" + selector + "\" must be a ruleset object.");
              }
            });
            break;
          }

        case '@import':
          {
            var _paths = globalSheet[rule];

            if (typeof _paths === 'string' || Array.isArray(_paths)) {
              _this2.emit('import', [sheet, (0, _aestheticUtils.toArray)(_paths).map(function (path) {
                return String(path);
              })]);
            } else if ("production" !== process.env.NODE_ENV) {
              throw new Error('@import must be a string or an array of strings.');
            }

            break;
          }

        case '@keyframes':
          {
            var frames = globalSheet[rule] || {};

            if ("production" !== process.env.NODE_ENV) {
              if (!(0, _aestheticUtils.isObject)(frames)) {
                throw new Error('@keyframes must be an object of animation names to keyframes.');
              }
            }

            Object.keys(frames).forEach(function (animationName) {
              _this2.convertKeyframe(animationName, frames[animationName], sheet);
            });
            break;
          }

        case '@page':
        case '@viewport':
          {
            var style = globalSheet[rule];

            if ((0, _aestheticUtils.isObject)(style)) {
              _this2.emit(rule.slice(1), [sheet, _this2.convertRuleset(style, sheet.createRuleset(rule))]);
            } else if ("production" !== process.env.NODE_ENV) {
              throw new Error(rule + " must be a ruleset object.");
            }

            break;
          }

        default:
          {
            if ("production" !== process.env.NODE_ENV) {
              throw new Error("Unknown property \"" + rule + "\". Only at-rules are allowed in the global style sheet.");
            }
          }
      }
    });
    return sheet;
  };

  _proto.convertStyleSheet = function convertStyleSheet(styleSheet, options) {
    var _this3 = this;

    var sheet = new _Sheet.default(options);
    Object.keys(styleSheet).forEach(function (selector) {
      var ruleset = styleSheet[selector];

      if (!ruleset) {
        return;
      }

      if (selector.charAt(0) === '@') {
        if ("production" !== process.env.NODE_ENV) {
          throw new SyntaxError("At-rules may not be defined in the root, found \"" + selector + "\".");
        }
      } else if (typeof ruleset === 'string') {
        if (ruleset.match(CLASS_NAME)) {
          sheet.addClassName(selector, ruleset);
        } else {
          sheet.addClassName(selector, _this3.convertRawCss(sheet, selector, ruleset));
        }
      } else if ((0, _aestheticUtils.isObject)(ruleset)) {
        sheet.addRuleset(_this3.convertRuleset(ruleset, sheet.createRuleset(selector)));
      } else if ("production" !== process.env.NODE_ENV) {
        throw new Error("Invalid ruleset for \"" + selector + "\". Must be an object or class name.");
      }
    });
    return sheet;
  };

  _proto.convertRawCss = function convertRawCss(sheet, selector, declaration) {
    var styleName = sheet.options.name;
    var className = styleName + "-" + selector;
    var stylis = new _stylis.default({
      compress: !("production" !== process.env.NODE_ENV),
      global: false,
      keyframe: true,
      prefix: true
    });

    if ((0, _aestheticUtils.isRTL)(sheet.options.dir)) {
      stylis.use(rtlPlugin);
    }

    this.emit('css', [stylis("." + className, declaration.trim()), className]);
    return className;
  };

  _proto.convertRuleset = function convertRuleset(unifiedRuleset, ruleset) {
    var _this4 = this;

    if ("production" !== process.env.NODE_ENV) {
      if (!(0, _aestheticUtils.isObject)(unifiedRuleset)) {
        throw new TypeError('Ruleset must be an object of properties.');
      }
    }

    var atRules = [];
    Object.keys(unifiedRuleset).forEach(function (baseKey) {
      var key = baseKey;
      var value = unifiedRuleset[key];

      if (typeof value === 'undefined') {
        return;
      }

      if (key.startsWith('@')) {
        atRules.push(key);
      } else if (key.startsWith(':') || key.startsWith('[')) {
        _this4.convertSelector(key, value, ruleset);
      } else {
        var newValue = _this4.emit("property:" + key, [ruleset, value]);

        _this4.emit('property', [ruleset, key, newValue || value]);
      }
    });
    atRules.forEach(function (key) {
      switch (key) {
        case '@fallbacks':
          {
            var fallbacks = unifiedRuleset[key] || {};

            if ("production" !== process.env.NODE_ENV) {
              if (!(0, _aestheticUtils.isObject)(fallbacks)) {
                throw new Error('@fallbacks must be an object of property names to fallback values.');
              }
            }

            Object.keys(fallbacks).forEach(function (property) {
              _this4.emit('fallback', [ruleset, property, (0, _aestheticUtils.toArray)(fallbacks[property])]);
            });
            break;
          }

        case '@media':
        case '@supports':
          {
            var styles = unifiedRuleset[key] || {};

            if ("production" !== process.env.NODE_ENV) {
              if (!(0, _aestheticUtils.isObject)(styles)) {
                throw new Error(key + " must be an object of queries to rulesets.");
              }
            }

            Object.keys(styles).forEach(function (query) {
              if ((0, _aestheticUtils.isObject)(styles[query])) {
                var event = key === '@media' ? 'media' : 'support';

                _this4.emit(event, [ruleset, query, _this4.convertRuleset(styles[query], ruleset.createRuleset(key + " " + query))]);
              } else if ("production" !== process.env.NODE_ENV) {
                throw new Error(key + " " + query + " must be a mapping of conditions to style objects.");
              }
            });
            break;
          }

        case '@selectors':
          {
            var selectors = unifiedRuleset[key] || {};

            if ("production" !== process.env.NODE_ENV) {
              if (!(0, _aestheticUtils.isObject)(selectors)) {
                throw new Error('@selectors must be an object of selectors to rulesets.');
              }
            }

            Object.keys(selectors).forEach(function (selector) {
              _this4.convertSelector(selector, selectors[selector], ruleset, true);
            });
            break;
          }

        default:
          {
            if ("production" !== process.env.NODE_ENV) {
              throw new SyntaxError("Unsupported local at-rule \"" + key + "\".");
            }
          }
      }
    });
    return ruleset;
  };

  _proto.convertSelector = function convertSelector(key, value, ruleset, inAtRule) {
    var _this5 = this;

    if (inAtRule === void 0) {
      inAtRule = false;
    }

    if ("production" !== process.env.NODE_ENV) {
      if (!(0, _aestheticUtils.isObject)(value)) {
        throw new Error("Selector \"" + key + "\" must be a ruleset object.");
      } else if ((key.includes(',') || !key.match(SELECTOR)) && !inAtRule) {
        throw new Error("Advanced selector \"" + key + "\" must be nested within an @selectors block.");
      }
    }

    key.split(',').forEach(function (k) {
      var selector = k.trim();
      var type = 'selector';

      if (selector.charAt(0) === ':') {
        type = 'pseudo';
      } else if (selector.charAt(0) === '[') {
        type = 'attribute';
      }

      _this5.emit(type, [ruleset, selector, _this5.convertRuleset(value, ruleset.createRuleset(selector))]);
    });
  };

  _proto.convertFontFaces = function convertFontFaces(fontFamily, faces, sheet) {
    var _this6 = this;

    var srcPaths = [];
    var fontFaces = faces.map(function (font) {
      srcPaths.push(font.srcPaths);
      return _this6.convertRuleset((0, _aestheticUtils.formatFontFace)(_extends({}, font, {
        fontFamily: fontFamily
      })), sheet.createRuleset(fontFamily));
    });
    this.emit('font-face', [sheet, fontFaces, fontFamily, srcPaths]);
  };

  _proto.convertKeyframe = function convertKeyframe(animationName, frames, sheet) {
    var _this7 = this;

    var keyframe = sheet.createRuleset(animationName);
    Object.keys(frames).forEach(function (key) {
      var value = frames[key];

      if (typeof value !== 'string' && typeof value !== 'undefined') {
        keyframe.addNested(key, _this7.convertRuleset(value, keyframe.createRuleset(key)));
      }
    });
    this.emit('keyframe', [sheet, keyframe, animationName]);
  };

  _proto.injectFontFaces = function injectFontFaces(value, cache) {
    if (value === void 0) {
      value = '';
    }

    if (cache === void 0) {
      cache = {};
    }

    var fontFaces = [];
    value.split(',').forEach(function (name) {
      var familyName = name.trim();
      var fonts = cache[familyName];

      if (Array.isArray(fonts)) {
        fontFaces.push.apply(fontFaces, fonts);
      } else {
        fontFaces.push(familyName);
      }
    });
    return fontFaces;
  };

  _proto.injectKeyframes = function injectKeyframes(value, cache) {
    if (value === void 0) {
      value = '';
    }

    if (cache === void 0) {
      cache = {};
    }

    return value.split(',').map(function (name) {
      var animationName = name.trim();
      return cache[animationName] || animationName;
    });
  };

  _proto.emit = function emit(eventName, args) {
    if (this.handlers[eventName]) {
      var _this$handlers;

      return (_this$handlers = this.handlers)[eventName].apply(_this$handlers, args);
    }

    return undefined;
  };

  _proto.off = function off(eventName) {
    delete this.handlers[eventName];
    return this;
  };

  _proto.on = function on(eventName, callback) {
    this.handlers[eventName] = callback;
    return this;
  };

  return UnifiedSyntax;
}();

exports.default = UnifiedSyntax;