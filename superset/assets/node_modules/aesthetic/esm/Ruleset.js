function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import convertRTL from 'rtl-css-js';
import { isRTL, toObjectRecursive } from 'aesthetic-utils';

var Ruleset = function () {
  function Ruleset(selector, root, parent) {
    if (parent === void 0) {
      parent = null;
    }

    _defineProperty(this, "compoundProperties", new Map());

    _defineProperty(this, "nested", new Map());

    _defineProperty(this, "parent", null);

    _defineProperty(this, "properties", {});

    _defineProperty(this, "root", void 0);

    _defineProperty(this, "selector", void 0);

    this.selector = selector;
    this.root = root;
    this.parent = parent;
  }

  var _proto = Ruleset.prototype;

  _proto.addCompoundProperty = function addCompoundProperty(key, value) {
    this.compoundProperties.set(key, value);
    return this;
  };

  _proto.addNested = function addNested(selector, ruleset, merge) {
    if (merge === void 0) {
      merge = true;
    }

    if (merge && this.nested.has(selector)) {
      this.nested.get(selector).merge(ruleset);
    } else {
      this.nested.set(selector, ruleset);
    }

    return this;
  };

  _proto.addProperty = function addProperty(key, value) {
    this.properties[key] = value;
    return this;
  };

  _proto.addProperties = function addProperties(properties) {
    Object.assign(this.properties, properties);
    return this;
  };

  _proto.createRuleset = function createRuleset(selector) {
    return new Ruleset(selector, this.root, this);
  };

  _proto.merge = function merge(ruleset) {
    var _this = this;

    Object.assign(this.properties, ruleset.properties);
    ruleset.nested.forEach(function (nested, selector) {
      _this.addNested(selector, nested);
    });
    return this;
  };

  _proto.toObject = function toObject() {
    var props = isRTL(this.root.options.dir) ? convertRTL(this.properties) : this.properties;
    var compounds = {};
    this.compoundProperties.forEach(function (compound, key) {
      compounds[key] = compound;
    });
    return _extends({}, props, {}, compounds, {}, toObjectRecursive(this.nested));
  };

  return Ruleset;
}();

export { Ruleset as default };