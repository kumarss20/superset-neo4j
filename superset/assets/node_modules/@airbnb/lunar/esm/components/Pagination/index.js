import React from 'react';
import PropTypes from 'prop-types';
import { requiredBy, mutuallyExclusiveTrueProps, forbidExtraProps } from 'airbnb-prop-types';
import IconChevronLeft from '@airbnb/lunar-icons/lib/interface/IconChevronLeft';
import IconChevronRight from '@airbnb/lunar-icons/lib/interface/IconChevronRight';
import IconFirst from '@airbnb/lunar-icons/lib/interface/IconFirst';
import IconLast from '@airbnb/lunar-icons/lib/interface/IconLast';
import useStyles from '../../hooks/useStyles';
import IconButton from '../IconButton';
import Text from '../Text';
import T from '../Translate';
import DirectionalIcon from '../DirectionalIcon';
import { styleSheet } from './styles';
import useTheme from '../../hooks/useTheme';

/** Pagination controls. */
function Pagination(_ref) {
  let {
    centerAlign,
    endAlign,
    fetching,
    hasNext,
    hasPrev,
    showBookends,
    startAlign,
    pageLabel = T.phrase('Page', {}, {
      context: 'Label for pages',
      key: 'lunar.common.page'
    }),
    onFirst,
    onLast,
    onNext,
    onPrevious,
    page,
    pageCount
  } = _ref;
  const [styles, cx] = useStyles(styleSheet);
  const theme = useTheme();

  if (!(hasNext || hasPrev)) {
    return null;
  }

  const previousPage = React.createElement(IconButton, {
    active: hasPrev,
    disabled: !hasPrev || fetching,
    onClick: onPrevious
  }, React.createElement(DirectionalIcon, {
    direction: "left",
    left: IconChevronLeft,
    right: IconChevronRight,
    accessibilityLabel: T.phrase('Load previous page', {}, {
      context: 'Load previous page when paginating sets of data',
      key: 'lunar.pagination.loadPrevious'
    }),
    size: 4 * theme.unit
  }));
  const nextPage = React.createElement(IconButton, {
    active: hasNext,
    disabled: !hasNext || fetching,
    onClick: onNext
  }, React.createElement(DirectionalIcon, {
    direction: "right",
    left: IconChevronLeft,
    right: IconChevronRight,
    accessibilityLabel: T.phrase('Load next page', {}, {
      context: 'Load next page when paginating sets of data',
      key: 'lunar.pagination.loadNext'
    }),
    size: 4 * theme.unit
  }));
  let firstPage = null;
  let lastPage = null;

  if (showBookends && typeof pageCount === 'number') {
    firstPage = React.createElement(IconButton, {
      active: hasPrev,
      disabled: page === 1 || fetching,
      onClick: onFirst
    }, React.createElement(DirectionalIcon, {
      direction: "left",
      left: IconFirst,
      right: IconLast,
      accessibilityLabel: T.phrase('Load first page', {}, {
        context: 'Load first page when paginating sets of data',
        key: 'lunar.pagination.loadFirst'
      }),
      size: 4 * theme.unit
    }));
    lastPage = React.createElement(IconButton, {
      active: hasNext,
      disabled: pageCount < 2 || pageCount === page || fetching,
      onClick: onLast
    }, React.createElement(DirectionalIcon, {
      direction: "right",
      left: IconFirst,
      right: IconLast,
      accessibilityLabel: T.phrase('Load last page', {}, {
        context: 'Load last page when paginating sets of data',
        key: 'lunar.pagination.loadLast'
      }),
      size: 4 * theme.unit
    }));
  }

  let paginationText = showBookends && pageCount ? React.createElement(T, {
    k: "lunar.pagination.pageCount",
    phrase: '%{pageNumber} of %{pageCount}',
    pageCount: pageCount,
    pageNumber: page,
    context: "Showing the current page number and total page count"
  }) : page;

  if (pageLabel) {
    paginationText = showBookends && pageCount ? React.createElement(T, {
      k: "lunar.pagination.pageCountLabeled",
      phrase: '%{pageLabel} %{pageNumber} of %{pageCount}',
      pageLabel: pageLabel,
      pageCount: pageCount,
      pageNumber: page,
      context: "Showing the current page number and total page count"
    }) : React.createElement(T, {
      k: "lunar.pagination.pageNumberLabeled",
      phrase: '%{pageLabel} %{pageNumber}',
      pageLabel: pageLabel,
      pageNumber: page,
      context: "Showing the current page number"
    });
  }

  return React.createElement("div", {
    className: cx(styles.wrapper, endAlign && styles.wrapper_endAlign, centerAlign && styles.wrapper_centerAlign, startAlign && styles.wrapper_startAlign)
  }, React.createElement("div", {
    className: cx(styles.previous)
  }, firstPage, previousPage), React.createElement("div", {
    className: cx(styles.page)
  }, React.createElement(Text, {
    muted: true
  }, paginationText)), React.createElement("div", {
    className: cx(styles.next)
  }, nextPage, lastPage));
}

const alignProp = mutuallyExclusiveTrueProps('centerAlign', 'endAlign', 'startAlign');
Pagination.propTypes = {
  onPrevious: PropTypes.func.isRequired,
  onNext: PropTypes.func.isRequired,
  pageLabel: PropTypes.string,
  page: PropTypes.number.isRequired,
  showBookends: PropTypes.bool,
  hasPrev: PropTypes.bool,
  hasNext: PropTypes.bool,
  fetching: PropTypes.bool,
  centerAlign: alignProp,
  endAlign: alignProp,
  pageCount: requiredBy('showBookends', PropTypes.number),
  startAlign: alignProp,
  onFirst: requiredBy('showBookends', PropTypes.func),
  onLast: requiredBy('showBookends', PropTypes.func)
};
export default Pagination;