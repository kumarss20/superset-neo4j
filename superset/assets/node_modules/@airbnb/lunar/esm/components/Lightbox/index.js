import _pt from "prop-types";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import Sheet from '../Sheet';
import LightboxImage from './Image';
import Header from './Header';
export default class Lightbox extends React.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      activeIndex: 0,
      hideAside: false,
      scale: 1,
      rotation: 0
    });

    _defineProperty(this, "preloadedUrls", new Map());

    _defineProperty(this, "handleChangeSlide", index => {
      this.setState({
        activeIndex: index,
        scale: 1,
        rotation: 0
      });
    });

    _defineProperty(this, "handleToggleAside", () => {
      this.setState((_ref) => {
        let {
          hideAside
        } = _ref;
        return {
          hideAside: !hideAside
        };
      });
    });

    _defineProperty(this, "handleZoomImage", scale => {
      this.setState({
        scale
      });
    });

    _defineProperty(this, "handleRotateImage", rotation => {
      this.setState({
        rotation
      });
    });
  }

  componentDidMount() {
    const {
      startIndex = 0,
      images
    } = this.props;
    const {
      activeIndex
    } = this.state;
    const index = startIndex < images.length ? startIndex : activeIndex;
    const totalImages = images.length;

    if (totalImages > 0) {
      this.preloadedUrls.set(images[index].src, true);

      if (totalImages > 1) {
        window.requestIdleCallback(() => this.preloadImages());
      }
    }

    if (index && activeIndex !== index) {
      this.handleChangeSlide(index);
    }
  }

  componentDidUpdate() {
    if (this.props.images.length > 1) {
      // prefetch the next image when `images` or `activeIndex` changes
      this.preloadImages();
    }
  }

  componentWillUnmount() {
    // We no longer need these images, so let's remove them so they can be garbage collected.
    this.preloadedUrls.clear();
  }

  preloadImages() {
    const {
      images
    } = this.props;
    const {
      activeIndex
    } = this.state;
    const totalImages = images.length; // Preload two images ahead

    const indices = [activeIndex + 1, activeIndex + 2];
    let preloadUrls = indices.map(preloadIndex => {
      const index = (preloadIndex + totalImages) % totalImages;
      return images[index] && images[index].src;
    }); // Filter out already preloaded images.

    preloadUrls = preloadUrls.filter(preloadUrl => preloadUrl && !this.preloadedUrls.has(preloadUrl)); // Preload each of the remaining images.

    preloadUrls.forEach(preloadUrl => {
      const img = new Image();
      img.src = preloadUrl; // The img object is stored as the value in an attempt to keep the object in memory and prevent garbage collection.

      this.preloadedUrls.set(preloadUrl, img);
    });
  }

  render() {
    const {
      onClose,
      images,
      showZoomControls,
      showRotateControls
    } = this.props;
    const {
      activeIndex,
      hideAside,
      scale,
      rotation
    } = this.state;
    const image = images[activeIndex];
    const {
      alt,
      aside,
      src
    } = image;
    const hasAside = images.some(img => !!img.aside);
    const header = React.createElement(Header, {
      activeIndex: activeIndex,
      imageCount: images.length,
      hideAside: hideAside,
      hasAside: hasAside,
      scale: scale,
      rotation: rotation,
      showZoomControls: showZoomControls,
      showRotateControls: showRotateControls,
      onChangeSlide: this.handleChangeSlide,
      onRotateImage: this.handleRotateImage,
      onToggleAside: this.handleToggleAside,
      onZoomImage: this.handleZoomImage
    });
    return React.createElement(Sheet, {
      compact: true,
      headerShadow: true,
      noAnimation: true,
      portal: true,
      visible: true,
      header: header,
      onClose: onClose
    }, React.createElement(LightboxImage, {
      aside: aside,
      alt: alt,
      src: src,
      hideAside: hideAside,
      scale: scale,
      rotation: rotation,
      showZoomControls: showZoomControls,
      showRotateControls: showRotateControls
    }));
  }

}

_defineProperty(Lightbox, "propTypes", {
  images: _pt.arrayOf(_pt.any).isRequired,
  startIndex: _pt.number,
  showZoomControls: _pt.bool,
  showRotateControls: _pt.bool,
  onClose: _pt.func.isRequired
});

_defineProperty(Lightbox, "defaultProps", {
  startIndex: 0
});