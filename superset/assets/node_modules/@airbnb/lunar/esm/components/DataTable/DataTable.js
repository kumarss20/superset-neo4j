function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import { CellMeasurerCache, SortDirection, Table } from 'react-virtualized';
import memoize from 'lodash/memoize';
import { styleSheetDataTable as styleSheet } from './styles';
import sortData from './helpers/sortData';
import expandData from './helpers/expandData';
import { indexData } from './helpers/indexData';
import ColumnLabels from './ColumnLabels';
import TableHeader from './TableHeader';
import renderDataColumns from './columns/renderDataColumns';
import renderExpandableColumn from './columns/renderExpandableColumn';
import renderSelectableColumn from './columns/renderSelectableColumn';
import withStyles from '../../composers/withStyles';
import { getRowColor, getHeight, getKeys } from './helpers';
import { HEIGHT_TO_PX, SELECTION_OPTIONS } from './constants';

/** A dynamic and responsive table for displaying tabular data. */
export class DataTable extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "state", {
      changeLog: {},
      expandedRows: new Set(),
      selectedRows: {},
      sortBy: this.props.sortByOverride || '',
      sortDirection: this.props.sortDirectionOverride,
      editMode: false
    });

    _defineProperty(this, "keys", getKeys(this.props.keys, this.props.data));

    _defineProperty(this, "getRowStyle", expandedDataList => (_ref) => {
      let {
        index
      } = _ref;
      return {
        background: getRowColor(expandedDataList[index], index, this.props.zebra || false, this.props.theme),
        display: 'flex',
        flexDirection: 'row',
        alignItems: 'center',
        borderBottom: this.props.showRowDividers ? '1px solid' : '',
        borderColor: this.props.theme.color.core.neutral[1],
        outline: 'none'
      };
    });

    _defineProperty(this, "getData", memoize((data, sortBy, sortDirection, selectedRows, sortByCacheKey) => {
      const {
        selectedRowsFirst,
        sortByValue
      } = this.props;
      const indexedData = indexData(data);
      const sortedData = sortData(indexedData, this.keys, selectedRows, selectedRowsFirst, sortBy, sortDirection, sortByValue);
      return sortedData;
    }, function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return JSON.stringify(args);
    }));

    _defineProperty(this, "getTableHeight", expandedDataList => {
      const {
        height,
        rowHeight,
        showAllRows,
        dynamicRowHeight
      } = this.props; // @ts-ignore _rowHeightCache is missing from DataTable types
      // eslint-disable-next-line no-underscore-dangle

      const rowHeights = this.cache._rowHeightCache;

      if (showAllRows) {
        if (dynamicRowHeight) {
          if (Object.values(rowHeights).length > 0) {
            const totalHeight = Object.values(rowHeights).reduce((sum, measuredRowHeight) => sum + measuredRowHeight, 0);
            return totalHeight + this.getColumnHeaderHeight();
          }

          this.forceUpdate();
        } else {
          return expandedDataList.length * getHeight(rowHeight) + this.getColumnHeaderHeight();
        }
      }

      return height || 0;
    });

    _defineProperty(this, "getColumnHeaderHeight", () => {
      const {
        columnHeaderHeight,
        rowHeight
      } = this.props;
      return getHeight(rowHeight, columnHeaderHeight);
    });

    _defineProperty(this, "shouldRenderTableHeader", () => {
      const {
        editable,
        extraHeaderButtons,
        tableHeaderLabel
      } = this.props;
      return editable || extraHeaderButtons.length > 0 || !!tableHeaderLabel;
    });

    _defineProperty(this, "sort", (_ref2) => {
      let {
        sortBy,
        sortDirection
      } = _ref2;
      this.cache.clearAll();
      const {
        sortOverride,
        sortCallback
      } = this.props;

      if (sortOverride && sortCallback) {
        sortCallback(sortBy, sortDirection);
      } else {
        this.setState({
          sortBy,
          sortDirection
        });
      }
    });

    _defineProperty(this, "expandRow", newExpandedRowOriginalIndex => event => {
      const {
        dynamicRowHeight
      } = this.props;
      event.stopPropagation();
      this.setState((_ref3) => {
        let {
          expandedRows
        } = _ref3;
        const newExpandedRows = new Set(expandedRows);

        if (expandedRows.has(newExpandedRowOriginalIndex)) {
          newExpandedRows.delete(newExpandedRowOriginalIndex);
        } else {
          newExpandedRows.add(newExpandedRowOriginalIndex);
        }

        return {
          expandedRows: newExpandedRows
        };
      });

      if (dynamicRowHeight) {
        // We need to make sure the cache is cleared before React tries to re-render.
        setTimeout(() => {
          this.cache.clearAll();
          this.forceUpdate();
        }, 0);
      }
    });

    _defineProperty(this, "onEdit", (row, key, newVal, event) => {
      const {
        defaultEditCallback,
        editCallbacks,
        instantEdit
      } = this.props;

      if (defaultEditCallback) {
        defaultEditCallback(row, key, newVal, event);
      }

      if (editCallbacks && editCallbacks[key]) {
        editCallbacks[key](row, key, newVal, event);
      }

      if (!instantEdit) {
        const {
          changeLog
        } = this.state;
        const {
          originalIndex
        } = row.rowData.metadata;

        if (changeLog[originalIndex] && changeLog[originalIndex][key]) {
          changeLog[originalIndex][key] = {
            newVal
          };
        } else {
          changeLog[originalIndex] = {
            [key]: {
              newVal
            }
          };
        }

        this.setState({
          changeLog
        });
      }
    });

    _defineProperty(this, "handleDisableEditMode", () => {
      this.setState({
        editMode: false
      });
    });

    _defineProperty(this, "handleEnactEdits", () => {
      const {
        enactEditsCallback
      } = this.props;
      const {
        changeLog
      } = this.state;
      this.setState({
        editMode: false
      });

      if (enactEditsCallback) {
        enactEditsCallback(changeLog);
      }
    });

    _defineProperty(this, "handleEnableEditMode", () => {
      this.setState({
        editMode: true
      });
    });

    _defineProperty(this, "handleChildSelection", row => {
      const {
        data,
        selectCallback,
        sortByCacheKey
      } = this.props;
      const {
        selectedRows,
        sortBy,
        sortDirection
      } = this.state;
      const sortedData = this.getData(data, sortBy, sortDirection, selectedRows, sortByCacheKey);
      const {
        parentOriginalIndex,
        parentIndex,
        originalIndex
      } = row.metadata; // If parent is already selected

      if (Object.prototype.hasOwnProperty.call(selectedRows, parentOriginalIndex)) {
        const {
          selectedChildren
        } = selectedRows[parentOriginalIndex]; // If child is already selected

        if (selectedChildren.has(originalIndex)) {
          selectedChildren.delete(originalIndex); // If there are now 0 selected children

          if (selectedChildren.size === 0) {
            delete selectedRows[parentOriginalIndex]; // If there is still at least one selected child
          } else {
            selectedRows[parentOriginalIndex].status = SELECTION_OPTIONS.HAS_ACTIVE_CHILD;
          } // If child is not already selected

        } else {
          selectedChildren.add(originalIndex); // If all children are now selected

          if (sortedData[parentIndex].metadata.children.length === selectedChildren.size) {
            selectedRows[parentOriginalIndex].status = SELECTION_OPTIONS.ACTIVE; // If not all children are now selected
          } else {
            selectedRows[parentOriginalIndex].status = SELECTION_OPTIONS.HAS_ACTIVE_CHILD;
          }
        } // If parent is not already selected

      } else {
        selectedRows[parentOriginalIndex] = {
          status: SELECTION_OPTIONS.HAS_ACTIVE_CHILD,
          selectedChildren: new Set([originalIndex])
        };
      }

      this.setState({
        selectedRows
      }, selectCallback(row, selectedRows));
    });

    _defineProperty(this, "handleSelection", rowData => () => {
      if (rowData.metadata.isChild) {
        this.handleChildSelection(rowData);
      } else {
        this.handleParentSelection(rowData);
      }
    });

    _defineProperty(this, "handleRowClick", (_ref4) => {
      let {
        rowData
      } = _ref4;
      return this.props.selectOnRowClick && this.handleSelection(rowData)();
    });

    _defineProperty(this, "rowGetter", expandedDataList => (_ref5) => {
      let {
        index
      } = _ref5;
      return expandedDataList[index];
    });

    _defineProperty(this, "cache", new CellMeasurerCache({
      fixedHeight: false,
      fixedWidth: true,
      defaultHeight: this.props.defaultDynamicRowHeight,
      minHeight: this.props.minimumDynamicRowHeight
    }));

    if (this.props.dataTableRef) {
      this.props.dataTableRef(this);
    }
  }

  componentDidUpdate(prevProps, prevState) {
    const {
      dynamicRowHeight,
      data,
      filterData,
      width,
      height,
      sortByCacheKey
    } = this.props;
    const {
      sortBy,
      sortDirection,
      selectedRows
    } = this.state;
    const dimensionsChanged = width !== prevProps.width || height !== prevProps.height;
    const sortChanged = sortBy !== prevState.sortBy || sortDirection !== prevState.sortDirection || sortByCacheKey !== prevProps.sortByCacheKey;
    const sortedData = this.getData(data, sortBy, sortDirection, selectedRows, sortByCacheKey);
    const filteredData = filterData(sortedData);
    const oldFilteredData = prevProps.filterData(sortedData);
    const filteredDataChanged = filteredData.length > 0 && (filteredData.length !== oldFilteredData.length || filteredData.some((x, i) => x.metadata.originalIndex !== oldFilteredData[i].metadata.originalIndex));

    if (dynamicRowHeight && (filteredDataChanged || dimensionsChanged || sortChanged)) {
      // We need to make sure the cache is cleared before React tries to re-render.
      setTimeout(() => {
        this.cache.clearAll();
        this.forceUpdate();
      }, 0);
    }

    if (this.props.data !== prevProps.data) {
      this.keys = getKeys(this.props.keys, this.props.data);
      this.setState({
        selectedRows: {},
        expandedRows: new Set()
      });
    }
  }

  handleParentSelection(row) {
    const {
      selectedRows
    } = this.state;
    const {
      selectCallback
    } = this.props;
    const {
      originalIndex
    } = row.metadata; // If parent is already selected

    if (Object.prototype.hasOwnProperty.call(selectedRows, originalIndex)) {
      delete selectedRows[originalIndex]; // If parent is not already selected
    } else {
      // Is there are children, select them all
      const children = row.metadata.children ? row.metadata.children.map(child => child.metadata.originalIndex) : [];
      selectedRows[originalIndex] = {
        status: SELECTION_OPTIONS.ACTIVE,
        selectedChildren: new Set(children)
      };
    }

    this.setState({
      selectedRows
    }, selectCallback(row, selectedRows));
  }

  renderTableHeader(parentWidth) {
    const {
      editable,
      extraHeaderButtons,
      instantEdit,
      rowHeight,
      tableHeaderLabel,
      tableHeaderHeight
    } = this.props;
    const {
      editMode,
      selectedRows
    } = this.state;
    return React.createElement(TableHeader, {
      extraHeaderButtons: extraHeaderButtons,
      editable: editable,
      tableHeaderLabel: tableHeaderLabel,
      selectedRows: selectedRows,
      instantEdit: instantEdit,
      editMode: editMode,
      height: getHeight(rowHeight, tableHeaderHeight),
      width: this.props.width ? Math.min(this.props.width, parentWidth) : parentWidth,
      onDisableEditMode: this.handleDisableEditMode,
      onEnableEditMode: this.handleEnableEditMode,
      onEnactEdits: this.handleEnactEdits
    });
  }

  render() {
    const {
      autoHeight,
      data,
      dynamicRowHeight,
      expandable,
      filterData,
      propagateRef,
      rowHeight,
      selectable,
      styles,
      selectedRowsFirst,
      tableHeaderHeight,
      cx,
      showAllRows,
      width,
      height,
      sortByCacheKey
    } = this.props;
    const {
      expandedRows,
      sortBy,
      sortDirection,
      editMode,
      selectedRows
    } = this.state;
    const sortedData = this.getData(data, sortBy, sortDirection, selectedRows, sortByCacheKey);
    const filteredData = filterData(sortedData);
    const expandedData = expandData(filteredData, expandedRows, selectedRows, selectedRowsFirst, sortBy, this.keys, sortDirection);
    const tableHeight = autoHeight ? (height || 0) - (this.shouldRenderTableHeader() ? getHeight(rowHeight, tableHeaderHeight) : 0) : this.getTableHeight(expandedData);
    return React.createElement(React.Fragment, null, this.shouldRenderTableHeader() && this.renderTableHeader(width), React.createElement("div", {
      className: cx(styles.table_container, {
        width
      })
    }, React.createElement(Table, {
      ref: propagateRef,
      height: tableHeight,
      width: width,
      rowCount: expandedData.length,
      rowGetter: this.rowGetter(expandedData),
      sort: this.sort,
      sortBy: sortBy,
      sortDirection: sortDirection,
      headerHeight: this.getColumnHeaderHeight(),
      headerRowRenderer: ColumnLabels(this.props),
      rowHeight: dynamicRowHeight ? this.cache.rowHeight : HEIGHT_TO_PX[rowHeight],
      rowStyle: this.getRowStyle(expandedData),
      overscanRowCount: dynamicRowHeight && showAllRows ? expandedData.length : 2,
      onRowClick: this.handleRowClick
    }, expandable && renderExpandableColumn(cx, styles, expandedRows, this.expandRow), selectable && renderSelectableColumn(selectedRows, this.handleSelection, expandable), renderDataColumns(this.keys, editMode, this.onEdit, this.cache, this.props))));
  }

}

_defineProperty(DataTable, "defaultProps", {
  autoHeight: false,
  columnHeaderHeight: undefined,
  columnLabelCase: '',
  columnMetadata: {},
  columnToLabel: {},
  data: [],
  defaultDynamicRowHeight: 16,
  defaultEditCallback: () => {},
  dynamicRowHeight: false,
  editable: false,
  editCallbacks: {},
  enactEditsCallback: () => {},
  expandable: false,
  extraHeaderButtons: [],
  filterData: data => data,
  height: 400,
  instantEdit: true,
  keys: [],
  minimumDynamicRowHeight: undefined,
  renderers: {},
  rowHeight: 'regular',
  selectable: false,
  // eslint-disable-next-line unicorn/consistent-function-scoping
  selectCallback: () => () => {},
  selectedRowsFirst: false,
  selectOnRowClick: false,
  showAllRows: false,
  showColumnDividers: false,
  showRowDividers: false,
  sortByOverride: '',
  sortCallback: () => {},
  sortDirectionOverride: SortDirection.ASC,
  sortOverride: false,
  tableHeaderHeight: undefined,
  tableHeaderLabel: '',
  width: 0,
  zebra: false
});

export default withStyles(styleSheet, {
  passThemeProp: true
})(DataTable);