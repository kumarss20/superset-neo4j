import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import debounce from 'lodash/debounce';
import BaseTextArea from '../../private/BaseTextArea';
import T from '../../Translate';
import Text from '../../Text';
import Link from '../../Link';
import Loader from '../../Loader';
import Dropdown from '../../Dropdown';
import withStyles from '../../../composers/withStyles';
import { LT_LOCALES } from '../../../constants';
import { ARROW_LEFT, ARROW_UP, ARROW_DOWN, ARROW_RIGHT } from '../../../keys';
import Mark from './Mark';
import SecondaryMark from './SecondaryMark';
import ErrorMenu from './ErrorMenu';
import LocaleMenu from './LocaleMenu';
import { styleSheet } from './styles';
const AIRBNB_REGEX = /\b(((air|ari|iar)[bn]{3})(?!\.com))\b/gi;
const NON_WORD_REGEX = /\W/;
const ARROW_KEYS = [ARROW_LEFT, ARROW_UP, ARROW_DOWN, ARROW_RIGHT];
const NO_LOCALE = 'none';
const AUTO_DETECT_LOCALE = 'auto';
const LOCALE_TO_LT_LOCALE = {
  de: 'de-DE',
  en: 'en-US',
  ja: 'ja-JP',
  pt: 'pt-PT',
  ru: 'ru-RU',
  zh: 'zh-CN'
};

function defaultIsRuleHighlighted(rule) {
  return false;
}

function defaultIsRuleSecondary(rule) {
  return false;
}

export class Proofreader extends React.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "caretRef", React.createRef());

    _defineProperty(this, "controlsRef", React.createRef());

    _defineProperty(this, "shadowRef", React.createRef());

    _defineProperty(this, "textareaRef", React.createRef());

    _defineProperty(this, "inputRaf", 0);

    _defineProperty(this, "syncScrollRaf", 0);

    _defineProperty(this, "scrollTimeout", 0);

    _defineProperty(this, "state", {
      errors: [],
      loading: false,
      position: null,
      selectedError: null,
      selectedLocale: null,
      showLocaleMenu: false,
      text: this.props.value,
      unsupportedLocale: null
    });

    _defineProperty(this, "checkTextDebounced", debounce(this.checkText, 2000, {
      leading: true
    }));

    _defineProperty(this, "syncScrollPositions", () => {
      if (!this.syncScrollRaf) {
        this.syncScrollRaf = requestAnimationFrame(this.performSyncScroll);
      }
    });

    _defineProperty(this, "performSyncScroll", () => {
      this.syncScrollRaf = 0;

      if (this.shadowRef.current && this.textareaRef.current) {
        const {
          current: shadow
        } = this.shadowRef;
        const {
          current: textarea
        } = this.textareaRef;
        shadow.style.minHeight = textarea.style.minHeight;
        shadow.style.height = textarea.style.height;
        shadow.scrollTop = textarea.scrollTop;
      }
    });

    _defineProperty(this, "handleTextAreaClick", event => {
      this.selectErrorAtPosition(event.currentTarget.selectionStart);
    });

    _defineProperty(this, "handleTextAreaKeyDown", event => {
      if (ARROW_KEYS.includes(event.key)) {
        this.selectErrorAtPosition(event.currentTarget.selectionStart);
      }
    });

    _defineProperty(this, "handleInput", () => {
      if (!this.inputRaf) {
        this.inputRaf = requestAnimationFrame(this.handleInputScroll);
      }
    });

    _defineProperty(this, "handleInputScroll", () => {
      this.inputRaf = 0;

      if (!this.textareaRef.current || !this.controlsRef.current) {
        return;
      }

      const el = this.textareaRef.current;
      const offset = this.getCaretOffset();
      const scrollBuffer = this.controlsRef.current.offsetHeight + 35; // At the bottom

      if (offset.top >= el.scrollHeight - scrollBuffer) {
        el.scrollTop = el.scrollHeight; // In the middle of the textarea, below the scroll
      } else if (offset.top >= el.offsetHeight + el.scrollTop - scrollBuffer) {
        el.scrollTop += scrollBuffer;
      }
    });

    _defineProperty(this, "handleOpenErrorMenu", (top, left) => {
      this.setState({
        position: {
          top: top - (this.textareaRef.current ? this.textareaRef.current.scrollTop : 0),
          left
        }
      });
    });

    _defineProperty(this, "handleReplaceText", (error, replacement) => {
      const {
        offset = 0
      } = error;
      const {
        errors,
        text
      } = this.state;
      let newText = '';
      newText += text.slice(0, offset);
      newText += replacement;
      newText += text.slice(offset + error.length);
      this.setState({
        text: newText,
        // Filter out this error
        errors: errors.filter(e => e !== error),
        // Close the error menu
        position: null,
        selectedError: null
      }, () => {
        // Kick off a non-debounced checkText, as this is coming directly from a replacement:
        this.checkText();
        const newOffset = offset + replacement.length;
        const textarea = this.textareaRef.current;

        if (!textarea) {
          return;
        } // Focus the textarea so we can reset the cursor position.


        textarea.focus();
        textarea.setSelectionRange(newOffset, newOffset); // Blurring and focusing the textarea will scroll the textarea to the cursor position,
        // which is what we need to do to avoid all our position syncing shenanigans.

        textarea.blur();
        textarea.focus();
      });

      if (this.props.onChange) {
        // We don't have a real event here, so fake one
        const event = {
          nativeEvent: new Event('change'),
          currentTarget: this.textareaRef,
          target: this.textareaRef,

          preventDefault() {}

        };
        this.props.onChange(newText, // @ts-ignore
        event);
      }
    });

    _defineProperty(this, "handleScroll", () => {
      this.syncScrollPositions();

      if (this.state.position) {
        this.setState({
          selectedError: null,
          position: null
        });
      } // When the textarea has trailing newlines, the scroll event
      // will not fire when scrolled to the very bottom, so we
      // get into a weird state where the scroll positions don't match.
      // Add a small timeout to fix this issue.


      window.clearTimeout(this.scrollTimeout);
      this.scrollTimeout = window.setTimeout(this.syncScrollPositions, 500);
    });

    _defineProperty(this, "handleSelectLocale", locale => {
      this.setState({
        selectedLocale: locale,
        showLocaleMenu: false
      }, () => {
        this.checkTextAndClearErrors();
      });
    });

    _defineProperty(this, "handleToggleLocaleMenu", () => {
      this.setState(prevState => ({
        showLocaleMenu: !prevState.showLocaleMenu
      }));
    });
  }

  getSnapshotBeforeUpdate() {
    if (!this.textareaRef.current) {
      return null;
    }

    return {
      selectionStart: this.textareaRef.current.selectionStart,
      selectionEnd: this.textareaRef.current.selectionEnd
    };
  }

  componentDidMount() {
    this.selectAppropriateLocale();
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    const {
      locale,
      value
    } = this.props;

    if (locale !== prevProps.locale) {
      this.selectAppropriateLocale();
    }

    if (value === prevProps.value) {
      // if value hasn't changed but other props have, make sure to retain original cursor position
      this.setCursorPosition(snapshot);
    } else {
      this.setState({
        text: value,
        errors: [],
        selectedError: null
      }, () => {
        // reset cursor position to original position after updating value
        this.setCursorPosition(snapshot);
      }); // Start checking when we encounter a non-word character so we can avoid
      // reporting misspellings for half-typed words.

      if (value.length > 0 && value.slice(-1).match(NON_WORD_REGEX)) {
        this.checkTextDebounced();
      } // If the user backspaces and removes a chunk of text, the scroll position
      // and dimensions may be out of sync, so we need to manually update them.
      // Don't use RAF though as it may take too long to render.


      if (value.length < prevProps.value.length) {
        window.setTimeout(this.performSyncScroll, 0);
      }
    }
  }

  componentWillUnmount() {
    if (this.syncScrollRaf) {
      cancelAnimationFrame(this.syncScrollRaf);
    }

    if (this.inputRaf) {
      cancelAnimationFrame(this.inputRaf);
    }
  }

  setCursorPosition(snapshot) {
    if (!snapshot) return;
    const {
      selectionStart,
      selectionEnd
    } = snapshot;
    const textarea = this.textareaRef.current;

    if (textarea && selectionStart && selectionEnd) {
      textarea.setSelectionRange(selectionStart, selectionEnd);
    }
  }

  checkText() {
    const {
      text,
      selectedLocale
    } = this.state;
    this.setState({
      loading: true,
      position: null,
      selectedError: null
    }); // Check for Airbnb misspellings

    const customErrors = this.checkForAirbnbErrors(text);

    if (!text || !selectedLocale || selectedLocale === NO_LOCALE) {
      this.setState({
        errors: [...customErrors],
        loading: false
      });
      return Promise.resolve();
    } // Check with language tool


    const params = {
      text,
      locale: selectedLocale,
      action: 'check'
    };
    return this.props.onCheckText(params).then((_ref) => {
      let {
        proofread
      } = _ref;
      this.setState({
        errors: [...customErrors, ...proofread.matches],
        loading: false
      });
    }).catch(() => {
      // Swallow errors
      this.setState({
        errors: [...customErrors],
        loading: false
      });
    });
  }

  checkTextAndClearErrors() {
    if (this.state.errors.length > 0) {
      this.setState({
        errors: []
      });
    }

    this.checkTextDebounced();
  }

  checkForAirbnbErrors(text) {
    const customErrors = [];

    if (!text) {
      return customErrors;
    }

    let match = AIRBNB_REGEX.exec(text);

    while (match) {
      if (match[0] !== 'Airbnb') {
        customErrors.push({
          short_message: '',
          message: T.phrase('Improper company spelling or casing', {}, {
            context: 'Error message when Airbnb is used incorrectly',
            key: 'lunar.proofreader.misspellingLabel'
          }),
          offset: AIRBNB_REGEX.lastIndex - match[0].length,
          length: match[0].length,
          found: match[0],
          replacements: ['Airbnb'],
          rule_id: 'AIRBNB_SPELLING_OR_CASING'
        });
      }

      match = AIRBNB_REGEX.exec(text);
    }

    return customErrors;
  }

  getLocaleDefinition(locale) {
    if (locale === NO_LOCALE) {
      return {
        locale,
        label: T.phrase('No language selected', {}, {
          context: 'No language selected for spell and grammar checking',
          key: 'lunar.proofreader.noLanguageSelected'
        })
      };
    }

    if (locale === AUTO_DETECT_LOCALE) {
      return {
        locale,
        label: T.phrase('Auto-detect language', {}, {
          context: 'Auto-detect language for spell and grammar checking',
          key: 'lunar.proofreader.autoDetectLanguage'
        })
      };
    }

    return LT_LOCALES.find(definition => definition.locale === locale);
  }

  getCaretOffset() {
    let top = 0;
    let left = 0;

    if (this.caretRef.current) {
      const child = this.caretRef.current.children[1];
      top = child.offsetTop;
      left = child.offsetLeft;
    }

    return {
      top,
      left
    };
  }

  selectAppropriateLocale() {
    const {
      locale: baseLocale
    } = this.props;
    const locale = LOCALE_TO_LT_LOCALE[baseLocale] || baseLocale || '';
    const possibleMatches = [];
    let match = null;

    if (locale === NO_LOCALE) {
      match = NO_LOCALE;
    } else if (locale === AUTO_DETECT_LOCALE) {
      match = AUTO_DETECT_LOCALE;
    } else {
      LT_LOCALES.some(definition => {
        if (locale === definition.locale) {
          match = definition.locale;
          return true;
        }

        if (locale.length === 2 && definition.locale.indexOf(locale) === 0) {
          possibleMatches.push(definition);
        }

        return false;
      });

      if (!match && possibleMatches.length > 0) {
        match = possibleMatches[0].locale;
      }
    }

    this.setState({
      selectedLocale: match,
      unsupportedLocale: match ? null : locale
    }, () => {
      this.checkTextAndClearErrors();
    });
  }
  /**
   * When clicking into a textarea, or moving the cursor around with arrow keys,
   * attempt to detect any current errors at the defined offsets.
   */


  selectErrorAtPosition(position) {
    const {
      errors
    } = this.state;

    if (errors.length === 0) {
      return;
    }

    const selectedError = errors.find(error => position >= (error.offset || 0) && position <= (error.offset || 0) + (error.length || 0)) || null;
    this.setState({
      selectedError
    });
  }

  renderTextWithMarks() {
    const {
      errors,
      selectedError,
      text
    } = this.state;

    if (errors.length === 0) {
      return text;
    } // Sort errors by offset otherwise slicing does not work


    errors.sort((a, b) => (a.offset || 0) - (b.offset || 0));
    const content = [];
    let lastIndex = 0;
    errors.forEach(error => {
      const offset = error.offset || 0;
      const length = error.length || 0;

      if (offset > text.length) {
        return;
      } // Extract previous string


      content.push(text.slice(lastIndex, offset)); // Set new last index

      lastIndex = offset + length; // Extract match and wrap in a component

      const word = text.slice(offset, lastIndex);
      const MarkComponent = this.props.isRuleSecondary(error) ? SecondaryMark : Mark;
      content.push(React.createElement(MarkComponent, {
        key: word + "-" + offset,
        selected: error === selectedError,
        alwaysHighlight: this.props.isRuleHighlighted(error),
        onSelect: this.handleOpenErrorMenu
      }, word));
    }); // Extract any remaining text

    content.push(text.slice(lastIndex)); // Add a fake character to the end of the text. This solves a handful of bugs
    // in which trailing new lines in combination with scroll position do not work correctly.

    content.push('.');
    return content;
  }

  render() {
    const _this$props = this.props,
          {
      cx,
      styles,
      theme,
      important
    } = _this$props,
          props = _objectWithoutPropertiesLoose(_this$props, ["cx", "children", "styles", "onCheckText", "theme", "important", "isRuleHighlighted", "isRuleSecondary"]);

    const {
      position,
      errors,
      loading,
      selectedError,
      selectedLocale,
      showLocaleMenu,
      unsupportedLocale,
      text
    } = this.state;
    const caretPosition = this.textareaRef.current && this.textareaRef.current.selectionStart || 0;
    const highlightsProps = {
      className: cx(styles.highlights, important && styles.highlights_important),
      ref: this.shadowRef
    };

    if (this.props.noTranslate) {
      highlightsProps.className += ' notranslate';
    }

    return React.createElement("div", {
      className: cx(styles.proofread)
    }, React.createElement("div", highlightsProps, this.renderTextWithMarks()), caretPosition > 0 && React.createElement("div", {
      ref: this.caretRef,
      className: cx(styles.caret)
    }, React.createElement("span", null, text.slice(0, caretPosition)), React.createElement("span", null, text.slice(caretPosition), ".")), React.createElement(BaseTextArea, _extends({}, props, {
      spellCheck: false,
      value: this.state.text,
      propagateRef: this.textareaRef,
      important: important,
      onClick: this.handleTextAreaClick,
      onKeyDown: this.handleTextAreaKeyDown,
      onScroll: this.handleScroll,
      onInput: this.handleInput
    })), position && selectedError && React.createElement(Dropdown, _extends({}, position, {
      zIndex: 5
    }), React.createElement(ErrorMenu, {
      error: selectedError,
      onReplaceText: this.handleReplaceText
    })), React.createElement("div", {
      ref: this.controlsRef,
      className: cx(styles.controls, important && styles.controls_important)
    }, React.createElement("span", {
      className: cx(styles.cell, {
        pointerEvents: 'initial'
      })
    }, React.createElement(Link, {
      small: true,
      onClick: this.handleToggleLocaleMenu
    }, selectedLocale ? this.getLocaleDefinition(selectedLocale).label : React.createElement(T, {
      k: "lunar.proofreader.unsupportedLanguage",
      phrase: "Unsupported language %{locale}",
      locale: unsupportedLocale || 'unknown',
      context: "Language is not supported for spelling detection"
    })), showLocaleMenu && React.createElement(Dropdown, {
      visible: true,
      top: "80%",
      left: theme.unit,
      zIndex: 5,
      onClickOutside: this.handleToggleLocaleMenu
    }, React.createElement(LocaleMenu // autoDefinition={this.getLocaleDefinition(AUTO_DETECT_LOCALE)}
    , {
      noneDefinition: this.getLocaleDefinition(NO_LOCALE),
      selectedLocale: selectedLocale,
      onSelectLocale: this.handleSelectLocale
    }))), errors.length > 0 && React.createElement("span", {
      className: cx(styles.cell)
    }, React.createElement(Text, {
      small: true,
      muted: true
    }, React.createElement(T, {
      k: "lunar.proofreader.totalIssues",
      phrase: "%{smartCount} issue||||%{smartCount} issues",
      smartCount: errors.length,
      context: "Showing the number of misspellings in a paragraph of text"
    }))), loading && React.createElement("span", {
      className: cx(styles.cell)
    }, React.createElement(Loader, {
      inline: true
    }))));
  }

}

_defineProperty(Proofreader, "propTypes", {
  locale: _pt.string,
  name: _pt.string.isRequired,
  id: _pt.string.isRequired,
  noTranslate: _pt.bool,
  onChange: _pt.func.isRequired,
  onCheckText: _pt.func.isRequired,
  value: _pt.string.isRequired
});

_defineProperty(Proofreader, "defaultProps", {
  isRuleHighlighted: defaultIsRuleHighlighted,
  isRuleSecondary: defaultIsRuleSecondary,
  locale: NO_LOCALE
});

export default withStyles(styleSheet, {
  passThemeProp: true
})(Proofreader);