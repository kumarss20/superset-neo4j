import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import FormInput from './FormInput';
import passThroughRef from '../../utils/passThroughRef';
export default class BaseTextArea extends React.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "textareaRef", null);

    _defineProperty(this, "reflowRaf", null);

    _defineProperty(this, "reflowTextarea", () => {
      this.reflowRaf = null;
      const ref = this.textareaRef;
      const {
        autoResize,
        minHeight,
        maxHeight
      } = this.props;

      if (!ref || !autoResize) {
        return;
      } // Fixed height is set when using the manual browser resizer (bottom right corner)


      const {
        height
      } = ref.style;
      const hasBeenResizedManually = height && height !== 'auto'; // Set heights to auto so that we can calculate the full height of the content

      ref.style.minHeight = 'auto';
      ref.style.height = 'auto'; // Determine the next height by clamping our boundaries

      const newMinHeight = Math.max(minHeight, Math.min(ref.scrollHeight, maxHeight)) + "px"; // If it has been manually resized outside our max, use that fixed height instead

      const newHeight = hasBeenResizedManually && height && parseFloat(height) > maxHeight ? height : 'auto'; // Set the new heights

      ref.style.minHeight = newMinHeight;
      ref.style.height = newHeight;
    });

    _defineProperty(this, "handleChange", event => {
      this.props.onChange(event.currentTarget.value, event);
    });

    _defineProperty(this, "loadRef", ref => {
      this.textareaRef = ref;

      if (ref) {
        this.reflowTextarea();
      }

      passThroughRef(this.props.propagateRef, ref);
    });
  }

  componentDidMount() {
    this.reflowTextarea();
  }

  componentDidUpdate(prevProps) {
    if (this.props.value !== prevProps.value && !this.reflowRaf) {
      this.reflowRaf = window.requestAnimationFrame(this.reflowTextarea);
    }
  }

  componentWillUnmount() {
    if (this.reflowRaf) {
      window.cancelAnimationFrame(this.reflowRaf);
    }
  }
  /* istanbul ignore next */


  render() {
    const _this$props = this.props,
          restProps = _objectWithoutPropertiesLoose(_this$props, ["autoResize", "maxHeight", "minHeight"]);

    return React.createElement(FormInput, _extends({}, restProps, {
      propagateRef: this.loadRef,
      tagName: "textarea",
      onChange: this.handleChange
    }));
  }

}

_defineProperty(BaseTextArea, "propTypes", {
  autoResize: _pt.bool,
  maxHeight: _pt.number,
  minHeight: _pt.number,
  onChange: _pt.func.isRequired
});

_defineProperty(BaseTextArea, "defaultProps", {
  autoResize: false,
  maxHeight: 400,
  maxLength: null,
  minHeight: 125,
  rows: 3,
  value: ''
});