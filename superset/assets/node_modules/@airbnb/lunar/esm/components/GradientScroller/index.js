import _pt from "prop-types";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
import IconChevronLeft from '@airbnb/lunar-icons/lib/interface/IconChevronLeft';
import IconChevronRight from '@airbnb/lunar-icons/lib/interface/IconChevronRight';
import withStyles from '../../composers/withStyles';
import DirectionalIcon from '../DirectionalIcon';
import { styleSheet } from './styles';
const INCREMENT = 25;

/** A horizontal scroller with gradients on each side. */
export class GradientScroller extends React.Component {
  constructor(props) {
    super(props); // Register resize observer before mounting

    _defineProperty(this, "contentsRef", null);

    _defineProperty(this, "observer", void 0);

    _defineProperty(this, "scrollInterval", 0);

    _defineProperty(this, "scrollerRef", null);

    _defineProperty(this, "state", {
      showStartGradient: false,
      showEndGradient: true
    });

    _defineProperty(this, "handleContentsRef", ref => {
      if (ref) {
        this.observer.observe(ref);
      } else if (this.contentsRef) {
        this.observer.unobserve(this.contentsRef);
      }

      this.contentsRef = ref;
    });

    _defineProperty(this, "handleScrollerRef", ref => {
      if (ref) {
        this.observer.observe(ref);
      } else if (this.scrollerRef) {
        this.observer.unobserve(this.scrollerRef);
      }

      this.scrollerRef = ref;
    });

    _defineProperty(this, "handleObserver", entries => {
      let calculate = false;
      entries.forEach((_ref) => {
        let {
          contentRect,
          target
        } = _ref;
        const width = target.dataset.prevWidth;
        const nextWidth = String(contentRect.width); // Dataset stores as strings

        if (!width || nextWidth !== width) {
          calculate = true; // eslint-disable-next-line no-param-reassign

          target.dataset.prevWidth = nextWidth;
        }
      });

      if (calculate) {
        this.handleResizeDebounced();
      }
    });

    _defineProperty(this, "handleResize", () => {
      this.calculate();
    });

    _defineProperty(this, "handleResizeDebounced", debounce(this.handleResize, 150));

    _defineProperty(this, "handleScroll", () => {
      const target = this.scrollerRef;
      const {
        showStartGradient,
        showEndGradient
      } = this.state;

      if (!target) {
        return;
      }

      if (target.scrollLeft > 0 && !showStartGradient) {
        this.setState({
          showStartGradient: true
        });
      } else if (target.scrollLeft === 0 && showStartGradient) {
        this.setState({
          showStartGradient: false
        });
      } // Get the largest width child to calculate against


      const scrolledWidth = target.scrollLeft + target.clientWidth;
      const maxChildWidth = this.calculateMaxChildWidth(target.children[0]);

      if (scrolledWidth < maxChildWidth && !showEndGradient) {
        this.setState({
          showEndGradient: true
        });
      } else if (scrolledWidth >= maxChildWidth && showEndGradient) {
        this.setState({
          showEndGradient: false
        });
      }
    });

    _defineProperty(this, "handleScrollThrottled", throttle(this.handleScroll, 100));

    _defineProperty(this, "handleScrollLeft", event => {
      this.doScroll(-this.calculateAutoScrollIncrement(), event.type !== 'click');
    });

    _defineProperty(this, "handleScrollRight", event => {
      this.doScroll(this.calculateAutoScrollIncrement(), event.type !== 'click');
    });

    _defineProperty(this, "handleScrollStop", () => {
      if (this.scrollInterval) {
        window.clearInterval(this.scrollInterval);
      }
    });

    this.observer = new window.ResizeObserver(this.handleObserver);
  }

  componentWillUnmount() {
    this.observer.disconnect();
  }

  calculate() {
    const scroller = this.scrollerRef;
    const contents = this.contentsRef;

    if (!scroller || !contents) {
      return;
    }

    const scrollerWidth = scroller.clientWidth;
    const maxChildWidth = this.calculateMaxChildWidth(contents);
    this.setState({
      showStartGradient: scroller.scrollLeft > 0,
      showEndGradient: maxChildWidth > scrollerWidth
    });
  }

  calculateAutoScrollIncrement() {
    let increment = this.props.autoScrollIncrement; // 15% of the width

    if (!increment && this.scrollerRef) {
      increment = this.scrollerRef.offsetWidth * 0.15;
    }

    if (!increment) {
      increment = INCREMENT;
    }

    return increment;
  }

  calculateMaxChildWidth(contents) {
    return Array.from(contents.children).reduce((width, child) => Math.max(child.clientWidth, width), contents.clientWidth);
  }

  doScroll(amount, interval) {
    if (interval === void 0) {
      interval = true;
    }

    // eslint-disable-next-line unicorn/consistent-function-scoping
    const callback = () => {
      if (this.scrollerRef) {
        this.scrollerRef.scrollLeft += amount;
        this.handleScrollThrottled();
      }
    };

    this.handleScrollStop();

    if (interval) {
      this.scrollInterval = window.setInterval(callback, 100);
    } else {
      callback();
    }
  }

  render() {
    const {
      cx,
      children,
      styles,
      hideScrollbar,
      showArrows
    } = this.props;
    const {
      showStartGradient,
      showEndGradient
    } = this.state;
    return React.createElement("div", {
      className: cx(styles.container)
    }, React.createElement("div", {
      className: cx(styles.leftGradient, showStartGradient && styles.gradient_reveal)
    }, showArrows ? React.createElement("button", {
      className: cx(styles.leftArrow, hideScrollbar && styles.arrow_hideScrollbar),
      type: "button",
      onClick: this.handleScrollLeft
    }, React.createElement(DirectionalIcon, {
      decorative: true,
      direction: "left",
      left: IconChevronLeft,
      right: IconChevronRight,
      size: "2em"
    })) : React.createElement("span", {
      className: cx(styles.scrollTrigger),
      onMouseEnter: this.handleScrollLeft,
      onMouseLeave: this.handleScrollStop
    })), React.createElement("div", {
      className: cx(styles.rightGradient, showEndGradient && styles.gradient_reveal)
    }, showArrows ? React.createElement("button", {
      className: cx(styles.rightArrow, hideScrollbar && styles.arrow_hideScrollbar),
      type: "button",
      onClick: this.handleScrollRight
    }, React.createElement(DirectionalIcon, {
      decorative: true,
      direction: "right",
      left: IconChevronLeft,
      right: IconChevronRight,
      size: "2em"
    })) : React.createElement("span", {
      className: cx(styles.scrollTrigger),
      onMouseEnter: this.handleScrollRight,
      onMouseLeave: this.handleScrollStop
    })), React.createElement("div", {
      ref: this.handleScrollerRef,
      className: cx(styles.scroller, hideScrollbar && styles.scroller_hideScrollbar),
      onScroll: this.handleScrollThrottled
    }, React.createElement("div", {
      ref: this.handleContentsRef,
      className: cx(styles.contents)
    }, children)));
  }

}

_defineProperty(GradientScroller, "propTypes", {
  autoScrollIncrement: _pt.number,
  children: _pt.node,
  hideScrollbar: _pt.bool,
  showArrows: _pt.bool
});

_defineProperty(GradientScroller, "defaultProps", {
  children: null,
  hideScrollbar: false,
  showArrows: false
});

export default withStyles(styleSheet)(GradientScroller);