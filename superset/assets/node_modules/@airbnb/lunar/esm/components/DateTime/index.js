import _pt from "prop-types";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import { mutuallyExclusiveTrueProps, forbidExtraProps } from 'airbnb-prop-types';
import createDateTime from '../../utils/createDateTime';
import Interval from '../Interval';
import Empty from '../Empty';
import T from '../Translate';
import toMilliseconds from '../../utils/toMilliseconds';
import { FORMAT_YMD, FORMAT_PREFIX_DAY, FORMAT_SUFFIX_TIMEZONE } from '../../constants';
import { timeBundle, dateMicroBundle, dateShortBundle, dateMediumBundle, dateLongBundle } from '../../messages';
const MINUTE_THRESHOLD = toMilliseconds('1 minute');
const MIN_RELATIVE_DATETIME_REFRESH_INTERVAL = toMilliseconds('5 seconds');
const MAX_RELATIVE_DATETIME_REFRESH_INTERVAL = toMilliseconds('6 hours');
const formatPropType = mutuallyExclusiveTrueProps('clock', 'micro', 'short', 'medium', 'long', 'relative', 'relativeCompact');

/** Display a formatted and localized timestamp. */
export default class DateTime extends React.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "renderTimeElement", () => {
      const formatted = DateTime.format(this.props);

      if (!formatted) {
        return React.createElement(Empty, null);
      }

      return React.createElement("time", {
        dateTime: this.rfc()
      }, formatted);
    });
  }

  static format(props) {
    const {
      at,
      clock,
      format: baseFormat,
      locale,
      long,
      medium,
      micro,
      noDay,
      noFuture,
      noTime,
      noTimezone,
      relative,
      relativeCompact,
      short,
      sourceFormat,
      timezone,
      withDay
    } = props;

    if (!at) {
      return '';
    } // Render a timestamp


    let timeStamp = createDateTime(at, {
      locale,
      sourceFormat,
      timezone
    });
    let format = baseFormat || '';
    let affixDay = withDay;
    let affixTime = true;

    if ("production" !== process.env.NODE_ENV) {
      if (!timeStamp.isValid) {
        throw new Error('Invalid timestamp passed to `DateTime`.');
      }
    } // Disable future dates


    if (noFuture) {
      const now = createDateTime(null, {
        timezone
      });

      if (timeStamp > now) {
        timeStamp = now;
      }
    } // Return early for relative timestamps


    if (relative || relativeCompact) {
      return DateTime.relative(timeStamp, {
        style: relativeCompact ? 'short' : 'long'
      });
    } // Determine base date format


    if (micro) {
      format = dateMicroBundle.get(locale);
    } else if (short) {
      format = dateShortBundle.get(locale);
    } else if (medium) {
      format = dateMediumBundle.get(locale);
    } else if (long) {
      format = dateLongBundle.get(locale);
      affixDay = true;
    } else if (clock) {
      format = timeBundle.get(locale);
      affixTime = false;
    } else {
      return timeStamp.toFormat(format);
    } // Prepend day


    if (affixDay && !noDay) {
      format = FORMAT_PREFIX_DAY + ", " + format;
    } // Append time


    if (affixTime && !noTime) {
      format += " " + timeBundle.get(locale);
    } // Append timezone


    if (!noTimezone) {
      format += " " + FORMAT_SUFFIX_TIMEZONE;
    }

    return timeStamp.toFormat(format);
  }

  static relative(timeStamp, options) {
    if (options === void 0) {
      options = {};
    }

    const relative = createDateTime(timeStamp);
    const diff = DateTime.diff(relative, options.base);
    const fewPhrase = options.style === 'narrow' ? T.phrase('a few sec.', {}, {
      context: 'Relative time within a minute',
      key: 'lunar.datetime.secsAgoNarrow'
    }) : T.phrase('a few seconds', {}, {
      context: 'Relative time within a minute',
      key: 'lunar.datetime.secsAgo'
    });

    if (diff > 0 && diff < MINUTE_THRESHOLD) {
      if (!options.style || options.style === 'long') {
        return T.phrase('in %{time}', {
          time: fewPhrase
        }, {
          context: 'Relative time explaining something will happen soon',
          key: 'lunar.datetime.in'
        });
      }

      return fewPhrase;
    }

    if (diff <= 0 && diff > -MINUTE_THRESHOLD) {
      if (!options.style || options.style === 'long') {
        return T.phrase('%{time} ago', {
          time: fewPhrase
        }, {
          context: 'Relative time explaining something recently happened',
          key: 'lunar.datetime.ago'
        });
      }

      return fewPhrase;
    }

    return relative.toRelative(options) || relative.toFormat(FORMAT_YMD);
  }

  static diff(to, from) {
    if (from === void 0) {
      from = null;
    }

    return createDateTime(to, {
      timezone: 'UTC'
    }).toMillis() - createDateTime(from, {
      timezone: 'UTC'
    }).toMillis();
  }

  getRefreshInterval() {
    const {
      at,
      sourceFormat
    } = this.props;
    const difference = Math.abs(DateTime.diff(createDateTime(at, {
      sourceFormat
    }))); // Decay refresh rate based on how long its been since the given timestamp
    // < 1 minute: update every 5 seconds
    // 10 minutes: update every 1 minute
    // 1 hour: update every 6 minutes
    // 1 day: update every 2.4 hours
    // > 2 day: update every 6 hours

    return Math.min(Math.max(difference / 10, MIN_RELATIVE_DATETIME_REFRESH_INTERVAL), MAX_RELATIVE_DATETIME_REFRESH_INTERVAL);
  }

  rfc() {
    const {
      at,
      sourceFormat
    } = this.props;
    return createDateTime(at, {
      sourceFormat
    }).toFormat("yyyy-MM-dd'T'HH:mm:ssZZ"); // RFC3339
  }

  render() {
    if (!this.props.relative) {
      return this.renderTimeElement();
    }

    return React.createElement(Interval, {
      key: this.rfc(),
      every: this.getRefreshInterval()
    }, this.renderTimeElement);
  }

}

_defineProperty(DateTime, "propTypes", {
  withDay: _pt.bool,
  timezone: _pt.oneOfType([_pt.string, _pt.bool]),
  sourceFormat: _pt.string,
  noTimezone: _pt.bool,
  noTime: _pt.bool,
  noFuture: _pt.bool,
  noDay: _pt.bool,
  locale: _pt.string,
  format: _pt.string,
  at: _pt.any,
  clock: formatPropType,
  long: formatPropType,
  medium: formatPropType,
  micro: formatPropType,
  relative: formatPropType,
  relativeCompact: formatPropType,
  short: formatPropType
});

_defineProperty(DateTime, "defaultProps", {
  at: null,
  clock: false,
  format: FORMAT_YMD,
  long: false,
  medium: false,
  micro: false,
  noDay: false,
  noFuture: false,
  noTime: false,
  noTimezone: false,
  relative: false,
  relativeCompact: false,
  short: false,
  sourceFormat: '',
  withDay: false
});