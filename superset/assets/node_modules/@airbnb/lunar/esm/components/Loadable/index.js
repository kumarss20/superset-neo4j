import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import ErrorMessage from '../ErrorMessage';
import Loader from '../Loader';
import renderElementOrFunction from '../../utils/renderElementOrFunction';

/**
 * A declarative component for async loading of other components via native `import()` and `React.lazy`.
 * @experimental Requires React.lazy
 */
export default class Loadable extends React.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      error: null,
      showLoading: this.props.delay <= 0
    });

    _defineProperty(this, "renderComponent", () => {
      const _this$props = this.props,
            {
        children,
        component
      } = _this$props,
            restProps = _objectWithoutPropertiesLoose(_this$props, ["children", "component", "delay", "error", "loading", "noError", "noLoading"]);

      const Component = React.lazy(component);

      if (typeof children === 'function') {
        // @ts-ignore Bug: https://github.com/Microsoft/TypeScript/issues/26970
        return children(Component, restProps);
      } // @ts-ignore Props spreading


      return React.createElement(Component, restProps, children);
    });

    _defineProperty(this, "renderError", () => {
      const {
        error
      } = this.state;
      const {
        error: renderable,
        noError
      } = this.props;

      if (!error || noError) {
        return null;
      }

      return renderElementOrFunction(renderable, error) || React.createElement(ErrorMessage, {
        error: error
      });
    });
  }

  static factory(component, initialProps) {
    if (initialProps === void 0) {
      initialProps = {};
    }

    return function LoadableFactory(props) {
      return React.createElement(Loadable, _extends({}, initialProps, props, {
        component: component
      }));
    };
  } // istanbul ignore next


  componentDidCatch(error) {
    this.setState({
      error
    });
  }

  componentDidMount() {
    const {
      delay
    } = this.props;

    if (delay && delay > 0) {
      window.setTimeout(() => {
        this.setState({
          showLoading: true
        });
      }, delay);
    }
  }

  renderLoading() {
    const {
      loading,
      noLoading
    } = this.props;

    if (!this.state.showLoading || noLoading) {
      return null;
    }

    return renderElementOrFunction(loading) || React.createElement(Loader, {
      static: true
    });
  }

  render() {
    if (this.state.error) {
      return this.renderError();
    }

    return React.createElement(React.Suspense, {
      fallback: this.renderLoading()
    }, this.renderComponent());
  }

}

_defineProperty(Loadable, "propTypes", {
  children: _pt.oneOfType([_pt.node, _pt.func]),
  component: _pt.func.isRequired,
  delay: _pt.number,
  error: _pt.any,
  loading: _pt.any,
  noError: _pt.bool,
  noLoading: _pt.bool
});

_defineProperty(Loadable, "defaultProps", {
  delay: 150,
  error: null,
  loading: null,
  noError: false,
  noLoading: false
});