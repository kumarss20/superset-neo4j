import _pt from "prop-types";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import { TAB } from '../../keys';
import focusableSelector from '../../utils/focusableSelector';

/** Automatically trap and apply focus to elements wrapped within. */
export default class FocusTrap extends React.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "nodeRef", React.createRef());

    _defineProperty(this, "handleKeyDown", event => {
      if (this.props.disabled || event.key !== TAB) {
        return;
      }

      const focusableElements = this.getFocusableElements();

      if (focusableElements.length === 0 || !document.activeElement) {
        return;
      }

      let focusIndex = focusableElements.indexOf(document.activeElement);
      const initialIndex = focusIndex;

      do {
        if (event.shiftKey) {
          if (focusIndex < 1) {
            // Currently focusing either the first element (focusIndex = 0),
            // or no element (focusIndex = -1), so jump to the last focusable element.
            focusIndex = focusableElements.length - 1;
          } else {
            focusIndex -= 1;
          }
        } else if (focusIndex === focusableElements.length - 1) {
          // Tabbing forward from end of trap, so jump to beginning.
          focusIndex = 0;
        } else {
          // Note that this also catches the case where focusIndex = -1,
          // in which case we focus index 0, which is the correct functionality.
          focusIndex += 1;
        }

        const element = focusableElements[focusIndex];

        if (element instanceof HTMLElement) {
          element.focus();
        } // On the off chance that we are able to begin tabbing in a trap with
        // only untabbable elements, we want to break out of an infinite loop.


        if (focusIndex === initialIndex) {
          break;
        } // Trying to focus on an element with e.g. display: none or visibility: hidden
        // will fail, so we need to find the next element to focus in that case.

      } while (document.activeElement !== focusableElements[focusIndex]);

      event.preventDefault();
    });
  }

  getFocusableElements() {
    if (!this.nodeRef.current) {
      return [];
    }

    return Array.from(this.nodeRef.current.querySelectorAll(focusableSelector));
  }

  render() {
    return (// eslint-disable-next-line jsx-a11y/no-static-element-interactions
      React.createElement("div", {
        ref: this.nodeRef,
        onKeyDown: this.handleKeyDown
      }, this.props.children)
    );
  }

}

_defineProperty(FocusTrap, "propTypes", {
  children: _pt.any.isRequired,
  disabled: _pt.bool
});

_defineProperty(FocusTrap, "defaultProps", {
  disabled: false
});