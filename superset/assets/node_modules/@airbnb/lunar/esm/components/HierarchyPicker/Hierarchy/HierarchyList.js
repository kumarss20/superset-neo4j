import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React from 'react';
import Text from '../../Text';
import useStyles from '../../../hooks/useStyles';
import HierarchyItem from './HierarchyItem';
import ItemDescription from './ItemDescription';
import { styleSheetList as styleSheet } from './styles';
export default function HierarchyList(_ref) {
  let {
    items = [],
    chosen = [],
    focus = [],
    maxHeight,
    renderItem,
    parents = [],
    onSubtree,
    onItemPicked,
    width,
    verticallyAlign
  } = _ref;
  const ref = React.createRef();
  const [styles, cx] = useStyles(styleSheet);
  const passThruProps = {
    chosen,
    maxHeight,
    renderItem,
    onSubtree,
    onItemPicked,
    width
  };

  const isChosen = definition => definition.every((name, i) => chosen[i] === name);
  /** Returns the closest <li> to the current document activeElement */


  const closestRowToActiveElement = () => {
    const {
      activeElement
    } = document;

    if (!activeElement || !activeElement.closest || !ref.current) {
      return null;
    }

    return activeElement.closest('li');
  };

  const handleDomFocusDeeper = () => {
    const li = closestRowToActiveElement();
    let deeper;

    if (verticallyAlign) {
      // next HierarchyList is a sibling
      const ul = li && li.parentElement;
      const parentDiv = ul && ul.parentElement;
      const nextMenu = parentDiv && parentDiv.nextElementSibling;
      deeper = nextMenu && nextMenu.querySelector('[tabindex]');
    } else {
      // next HierarchyList is a child
      const ul = li && li.lastElementChild;
      deeper = ul && ul.querySelector('[tabindex]');
    }

    if (deeper) {
      deeper.focus();
    }
  };

  const handleDomFocusShallower = () => {
    const li = closestRowToActiveElement();
    let shallower;

    if (verticallyAlign) {
      // prev HierarchyList is a sibling
      const ul = li && li.parentElement;
      const parentDiv = ul && ul.parentElement;
      const prevMenu = parentDiv && parentDiv.previousElementSibling; // focused parent tabIndex is higher than other parents

      shallower = prevMenu && prevMenu.querySelector('[tabindex="1"]');
    } else {
      // prev HierarchyList is a parent
      const parentLi = li && li.parentElement && li.parentElement.closest('li');
      shallower = parentLi && parentLi.querySelector('[tabindex]');
    }

    if (shallower) {
      shallower.focus();
    }
  };

  const renderAside = item => {
    if (item.items || !item.description) {
      return null;
    }

    return React.createElement("aside", {
      className: cx(styles.pane, // descriptions are always nested
      styles.pane_nested, !verticallyAlign && styles.pane_verticallyOffset, styles.aside, {
        width
      })
    }, React.createElement("button", {
      className: cx(styles.asideButton),
      tabIndex: -1,
      type: "button",
      onClick: () => onItemPicked([...parents, item.name])
    }, React.createElement(ItemDescription, {
      item: item
    })));
  };

  if (items.length === 0) {
    return null;
  }

  const [focusName, ...focusRest] = focus;
  const isNested = parents.length > 0; // Track focused item to render as a sibling if vertically aligned

  let focusedItem;
  let currentSection;
  return React.createElement(React.Fragment, null, React.createElement("div", {
    key: "list",
    ref: ref,
    className: cx(styles.pane, verticallyAlign && styles.pane_verticallyAlign, isNested && styles.pane_nested, isNested && !verticallyAlign && styles.pane_verticallyOffset, {
      width,
      maxHeight: verticallyAlign ? maxHeight : undefined,
      zIndex: 1
    })
  }, React.createElement("ul", {
    className: cx(styles.list)
  }, items.map((item, index) => {
    const {
      name,
      section
    } = item;
    const definition = parents.concat(name);
    const isFocused = name === focusName;
    const shouldRenderSection = typeof section === 'string' && section !== currentSection;
    focusedItem = verticallyAlign && isFocused ? item : focusedItem;
    currentSection = shouldRenderSection ? section : currentSection;
    return React.createElement(React.Fragment, {
      key: item.name
    }, shouldRenderSection && index > 0 ? React.createElement("li", {
      className: cx(styles.divider)
    }) : null, shouldRenderSection && section ? React.createElement("li", {
      className: cx(styles.sectionHeader)
    }, React.createElement(Text, {
      small: true,
      bold: true,
      uppercased: true
    }, section)) : null, React.createElement("li", {
      className: cx(styles.row)
    }, React.createElement(HierarchyItem, _extends({}, passThruProps, {
      item: item,
      definition: definition,
      selected: isChosen(definition),
      focused: isFocused,
      onDomFocusDeeper: handleDomFocusDeeper,
      onDomFocusShallower: handleDomFocusShallower
    })), !verticallyAlign && isFocused && item.items && item.items.length > 0 ? React.createElement(HierarchyList, _extends({}, passThruProps, {
      items: item.items,
      focus: focusRest,
      parents: parents.concat(item.name),
      verticallyAlign: false
    })) : !verticallyAlign && isFocused && renderAside(item)));
  }))), verticallyAlign && focusedItem && focusedItem.items && focusedItem.items.length > 0 ? React.createElement(HierarchyList, _extends({
    key: "sub-list"
  }, passThruProps, {
    verticallyAlign: true,
    items: focusedItem.items,
    focus: focusRest,
    parents: parents.concat(focusedItem.name)
  })) : verticallyAlign && focusedItem && renderAside(focusedItem));
}
HierarchyList.propTypes = {
  items: _pt.arrayOf(_pt.any),
  chosen: _pt.any,
  focus: _pt.any.isRequired,
  maxHeight: _pt.number,
  renderItem: _pt.any,
  parents: _pt.any,
  onSubtree: _pt.func.isRequired,
  onItemPicked: _pt.func.isRequired,
  width: _pt.number,
  verticallyAlign: _pt.bool
};