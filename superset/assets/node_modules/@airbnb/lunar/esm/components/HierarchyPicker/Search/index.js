import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import Fuse from 'fuse.js';
import Autocomplete from '../../Autocomplete';
import SearchResult from './SearchResult';
import T from '../../Translate';
import withStyles from '../../../composers/withStyles';
import { styleSheet } from './styles';
const defaultFuseOptions = {
  shouldSort: true,
  includeMatches: true,
  tokenize: true,
  matchAllTokens: true,
  findAllMatches: true,
  threshold: 0.1,
  distance: 200,
  maxPatternLength: 32,
  minMatchCharLength: 3
};
const defaultFuseKeys = [{
  name: 'label',
  weight: 0.8
}, {
  name: 'keywords',
  weight: 0.7
}, {
  name: 'description',
  weight: 0.5
}];
export class Search extends React.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "fuse", void 0);

    _defineProperty(this, "getItemValue", result => result.item.name);

    _defineProperty(this, "handleItemPicked", (itemValue, result) => {
      const {
        query,
        onItemPicked
      } = this.props;
      onItemPicked(result && result.item.definition || null, {
        origin: 'Search',
        charCount: query.length
      });
    });

    _defineProperty(this, "handleSearch", query => {
      const trimmedQuery = query.trim();

      if (!trimmedQuery || !this.fuse) {
        return [];
      }

      return this.fuse.search(trimmedQuery);
    });

    _defineProperty(this, "handleAsyncSearch", query => Promise.resolve(this.handleSearch(query)));

    _defineProperty(this, "renderItem", (_ref) => {
      let {
        matches,
        item: {
          formattedParents
        }
      } = _ref,
          item = _objectWithoutPropertiesLoose(_ref.item, ["formattedParents"]);

      const {
        query
      } = this.props;
      return React.createElement(SearchResult, {
        query: (query || '').toLowerCase(),
        item: item,
        formattedParents: formattedParents,
        matches: matches
      });
    });
  }

  componentDidMount() {
    this.buildIndex(this.props.items);
  }

  componentDidUpdate(prevProps) {
    const {
      items,
      indexParentPath
    } = this.props;

    if (items !== prevProps.items || indexParentPath !== prevProps.indexParentPath) {
      this.buildIndex(items);
    }
  }

  buildIndex(inputItems) {
    var _this = this;

    if (inputItems === void 0) {
      inputItems = [];
    }

    const flatItemList = [];

    const walk = function walk(one, parents) {
      if (parents === void 0) {
        parents = [];
      }

      const definition = [...parents, one.name];

      const {
        items
      } = one,
            item = _objectWithoutPropertiesLoose(one, ["items"]);

      const {
        readonly
      } = item;

      if (!readonly) {
        flatItemList.push(_extends({}, item, {
          definition,
          label: item.label || item.name,
          formattedParents: parents.length > 0 ? _this.props.formatter([...parents, '']) : ''
        }));
      }

      (items || []).forEach(sub => walk(sub, definition));
    };

    if (inputItems) {
      inputItems.forEach(item => walk(item));
    }

    const fuseKeys = [...defaultFuseKeys];

    if (this.props.indexParentPath) {
      fuseKeys.push({
        name: 'formattedParents',
        weight: 0.2
      });
    }

    const fuseOptions = _extends({}, defaultFuseOptions, {
      keys: fuseKeys
    });

    this.fuse = new Fuse(flatItemList, _extends({}, fuseOptions, {}, this.props.fuseOptions));
  }

  render() {
    const {
      cx,
      noResultsLabel,
      maxHeight,
      onSearch,
      placeholder,
      query,
      styles,
      width
    } = this.props;
    return React.createElement("div", {
      className: cx(styles.container, {
        width: query ? width : undefined
      })
    }, React.createElement(Autocomplete, {
      hideLabel: true,
      optional: true,
      accessibilityLabel: T.phrase('Hierarchy item search', {}, {
        context: 'Search functionality to find items within the hierarchy menu.',
        key: 'lunar.picker.searchLabel'
      }),
      getItemValue: this.getItemValue,
      maxHeight: maxHeight,
      name: "autocomplete-search",
      noResultsText: noResultsLabel,
      value: query,
      type: "search",
      renderItem: this.renderItem,
      label: "",
      placeholder: placeholder,
      onSelectItem: this.handleItemPicked,
      onLoadItems: this.handleAsyncSearch,
      onChange: onSearch
    }));
  }

}

_defineProperty(Search, "propTypes", {
  items: _pt.arrayOf(_pt.any),
  onItemPicked: _pt.func.isRequired,
  formatter: _pt.any.isRequired,
  query: _pt.string,
  noResultsLabel: _pt.any.isRequired,
  onSearch: _pt.func.isRequired,
  placeholder: _pt.string,
  indexParentPath: _pt.bool,
  fuseOptions: _pt.any,
  width: _pt.number.isRequired,
  maxHeight: _pt.number
});

_defineProperty(Search, "defaultProps", {
  fuseOptions: {},
  items: [],
  query: ''
});

export default withStyles(styleSheet)(Search);