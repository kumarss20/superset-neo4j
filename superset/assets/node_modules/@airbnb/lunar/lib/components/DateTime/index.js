"use strict";

exports.__esModule = true;
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _airbnbPropTypes = require("airbnb-prop-types");

var _createDateTime = _interopRequireDefault(require("../../utils/createDateTime"));

var _Interval = _interopRequireDefault(require("../Interval"));

var _Empty = _interopRequireDefault(require("../Empty"));

var _Translate = _interopRequireDefault(require("../Translate"));

var _toMilliseconds = _interopRequireDefault(require("../../utils/toMilliseconds"));

var _constants = require("../../constants");

var _messages = require("../../messages");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const MINUTE_THRESHOLD = (0, _toMilliseconds.default)('1 minute');
const MIN_RELATIVE_DATETIME_REFRESH_INTERVAL = (0, _toMilliseconds.default)('5 seconds');
const MAX_RELATIVE_DATETIME_REFRESH_INTERVAL = (0, _toMilliseconds.default)('6 hours');
const formatPropType = (0, _airbnbPropTypes.mutuallyExclusiveTrueProps)('clock', 'micro', 'short', 'medium', 'long', 'relative', 'relativeCompact');

/** Display a formatted and localized timestamp. */
class DateTime extends _react.default.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "renderTimeElement", () => {
      const formatted = DateTime.format(this.props);

      if (!formatted) {
        return _react.default.createElement(_Empty.default, null);
      }

      return _react.default.createElement("time", {
        dateTime: this.rfc()
      }, formatted);
    });
  }

  static format(props) {
    const {
      at,
      clock,
      format: baseFormat,
      locale,
      long,
      medium,
      micro,
      noDay,
      noFuture,
      noTime,
      noTimezone,
      relative,
      relativeCompact,
      short,
      sourceFormat,
      timezone,
      withDay
    } = props;

    if (!at) {
      return '';
    } // Render a timestamp


    let timeStamp = (0, _createDateTime.default)(at, {
      locale,
      sourceFormat,
      timezone
    });
    let format = baseFormat || '';
    let affixDay = withDay;
    let affixTime = true;

    if ("production" !== process.env.NODE_ENV) {
      if (!timeStamp.isValid) {
        throw new Error('Invalid timestamp passed to `DateTime`.');
      }
    } // Disable future dates


    if (noFuture) {
      const now = (0, _createDateTime.default)(null, {
        timezone
      });

      if (timeStamp > now) {
        timeStamp = now;
      }
    } // Return early for relative timestamps


    if (relative || relativeCompact) {
      return DateTime.relative(timeStamp, {
        style: relativeCompact ? 'short' : 'long'
      });
    } // Determine base date format


    if (micro) {
      format = _messages.dateMicroBundle.get(locale);
    } else if (short) {
      format = _messages.dateShortBundle.get(locale);
    } else if (medium) {
      format = _messages.dateMediumBundle.get(locale);
    } else if (long) {
      format = _messages.dateLongBundle.get(locale);
      affixDay = true;
    } else if (clock) {
      format = _messages.timeBundle.get(locale);
      affixTime = false;
    } else {
      return timeStamp.toFormat(format);
    } // Prepend day


    if (affixDay && !noDay) {
      format = _constants.FORMAT_PREFIX_DAY + ", " + format;
    } // Append time


    if (affixTime && !noTime) {
      format += " " + _messages.timeBundle.get(locale);
    } // Append timezone


    if (!noTimezone) {
      format += " " + _constants.FORMAT_SUFFIX_TIMEZONE;
    }

    return timeStamp.toFormat(format);
  }

  static relative(timeStamp, options) {
    if (options === void 0) {
      options = {};
    }

    const relative = (0, _createDateTime.default)(timeStamp);
    const diff = DateTime.diff(relative, options.base);
    const fewPhrase = options.style === 'narrow' ? _Translate.default.phrase('a few sec.', {}, {
      context: 'Relative time within a minute',
      key: 'lunar.datetime.secsAgoNarrow'
    }) : _Translate.default.phrase('a few seconds', {}, {
      context: 'Relative time within a minute',
      key: 'lunar.datetime.secsAgo'
    });

    if (diff > 0 && diff < MINUTE_THRESHOLD) {
      if (!options.style || options.style === 'long') {
        return _Translate.default.phrase('in %{time}', {
          time: fewPhrase
        }, {
          context: 'Relative time explaining something will happen soon',
          key: 'lunar.datetime.in'
        });
      }

      return fewPhrase;
    }

    if (diff <= 0 && diff > -MINUTE_THRESHOLD) {
      if (!options.style || options.style === 'long') {
        return _Translate.default.phrase('%{time} ago', {
          time: fewPhrase
        }, {
          context: 'Relative time explaining something recently happened',
          key: 'lunar.datetime.ago'
        });
      }

      return fewPhrase;
    }

    return relative.toRelative(options) || relative.toFormat(_constants.FORMAT_YMD);
  }

  static diff(to, from) {
    if (from === void 0) {
      from = null;
    }

    return (0, _createDateTime.default)(to, {
      timezone: 'UTC'
    }).toMillis() - (0, _createDateTime.default)(from, {
      timezone: 'UTC'
    }).toMillis();
  }

  getRefreshInterval() {
    const {
      at,
      sourceFormat
    } = this.props;
    const difference = Math.abs(DateTime.diff((0, _createDateTime.default)(at, {
      sourceFormat
    }))); // Decay refresh rate based on how long its been since the given timestamp
    // < 1 minute: update every 5 seconds
    // 10 minutes: update every 1 minute
    // 1 hour: update every 6 minutes
    // 1 day: update every 2.4 hours
    // > 2 day: update every 6 hours

    return Math.min(Math.max(difference / 10, MIN_RELATIVE_DATETIME_REFRESH_INTERVAL), MAX_RELATIVE_DATETIME_REFRESH_INTERVAL);
  }

  rfc() {
    const {
      at,
      sourceFormat
    } = this.props;
    return (0, _createDateTime.default)(at, {
      sourceFormat
    }).toFormat("yyyy-MM-dd'T'HH:mm:ssZZ"); // RFC3339
  }

  render() {
    if (!this.props.relative) {
      return this.renderTimeElement();
    }

    return _react.default.createElement(_Interval.default, {
      key: this.rfc(),
      every: this.getRefreshInterval()
    }, this.renderTimeElement);
  }

}

exports.default = DateTime;

_defineProperty(DateTime, "propTypes", {
  withDay: _propTypes.default.bool,
  timezone: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.bool]),
  sourceFormat: _propTypes.default.string,
  noTimezone: _propTypes.default.bool,
  noTime: _propTypes.default.bool,
  noFuture: _propTypes.default.bool,
  noDay: _propTypes.default.bool,
  locale: _propTypes.default.string,
  format: _propTypes.default.string,
  at: _propTypes.default.any,
  clock: formatPropType,
  long: formatPropType,
  medium: formatPropType,
  micro: formatPropType,
  relative: formatPropType,
  relativeCompact: formatPropType,
  short: formatPropType
});

_defineProperty(DateTime, "defaultProps", {
  at: null,
  clock: false,
  format: _constants.FORMAT_YMD,
  long: false,
  medium: false,
  micro: false,
  noDay: false,
  noFuture: false,
  noTime: false,
  noTimezone: false,
  relative: false,
  relativeCompact: false,
  short: false,
  sourceFormat: '',
  withDay: false
});