"use strict";

exports.__esModule = true;
exports.default = exports.Tooltip = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _v = _interopRequireDefault(require("uuid/v4"));

var _Overlay = _interopRequireDefault(require("../Overlay"));

var _NotchedBox = _interopRequireWildcard(require("../NotchedBox"));

var _Text = _interopRequireDefault(require("../Text"));

var _withStyles = _interopRequireDefault(require("../../composers/withStyles"));

var _styles = require("./styles");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const EMPTY_TARGET_RECT = {
  bottom: 0,
  height: 0,
  left: 0,
  right: 0,
  top: 0,
  width: 0
};

/** A tooltip that renders in an portal, so it can escape potentially overflowed containers. */
class Tooltip extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      labelID: (0, _v.default)(),
      open: false,
      tooltipHeight: 0,
      targetRect: EMPTY_TARGET_RECT
    });

    _defineProperty(this, "containerRef", _react.default.createRef());

    _defineProperty(this, "currentTooltipRef", null);

    _defineProperty(this, "rafHandle", void 0);

    _defineProperty(this, "handleTooltipRef", ref => {
      this.currentTooltipRef = ref;
      this.updateTooltipHeight();
    });

    _defineProperty(this, "handleEnter", () => {
      const {
        current
      } = this.containerRef;
      /* istanbul ignore if: refs are hard */

      if (current) {
        this.setState({
          targetRect: current.getBoundingClientRect()
        });
      }

      if (!this.props.disabled && !this.state.open) {
        this.setState({
          open: true
        });
        this.props.onShow();
      }
    });

    _defineProperty(this, "handleMouseDown", () => {
      if (!this.props.remainOnMouseDown) {
        this.handleClose();
      }
    });

    _defineProperty(this, "handleClose", () => {
      this.setState({
        open: false
      });
    });
  }

  static getDerivedStateFromProps(_ref) {
    let {
      disabled
    } = _ref;

    if (disabled) {
      return {
        open: false
      };
    }

    return null;
  }

  componentDidMount() {
    // eslint-disable-next-line react/no-did-mount-set-state
    this.setState({
      targetRect: document.body.getBoundingClientRect()
    });
  }

  componentDidUpdate(prevProps) {
    if (prevProps.content !== this.props.content) {
      this.updateTooltipHeight();
    }
  }

  componentWillUnmount() {
    cancelAnimationFrame(this.rafHandle);
  }

  updateTooltipHeight() {
    // we need to know the height of the tooltip to position it above target

    /* istanbul ignore next: refs are hard */
    this.rafHandle = requestAnimationFrame(() => {
      const el = this.currentTooltipRef;
      this.setState({
        tooltipHeight: el ? el.offsetHeight : 0
      });
    });
  }

  bestPosition(rect) {
    const output = {
      above: false,
      align: 'left'
    };
    const {
      width: widthProp,
      theme
    } = this.props;
    /* istanbul ignore next: refs are hard */

    if (rect && widthProp && theme) {
      const {
        width: targetWidth,
        left,
        right,
        top
      } = rect;
      const {
        unit
      } = theme;
      const rightSpace = window.innerWidth - right;

      if (top > window.innerHeight * 0.6) {
        output.above = true;
      }

      if (Math.min(left, rightSpace) - unit > (widthProp * unit - targetWidth) / 2) {
        output.align = 'center';
      } else if (rightSpace < left) {
        output.align = 'right';
      }
    }

    return output;
  }

  render() {
    const {
      cx,
      styles,
      theme,
      width: widthProp,
      children,
      content,
      disabled,
      underlined,
      inverted
    } = this.props;
    const {
      open,
      targetRect,
      tooltipHeight,
      labelID
    } = this.state;
    const {
      unit
    } = theme;
    const width = widthProp * unit;
    const {
      align,
      above
    } = this.bestPosition(targetRect);
    const targetWidth = targetRect.width;
    const halfNotch = _NotchedBox.NOTCH_SIZE * unit / Math.SQRT2;
    const notchOffset = {
      center: '50%',
      right: -(unit * _NotchedBox.NOTCH_SPACING + halfNotch)
    };
    const marginLeft = {
      center: -width / 2 + targetWidth / 2,
      right: -width + targetWidth
    };
    const distance = halfNotch + 1;
    return _react.default.createElement("span", {
      ref: this.containerRef,
      className: cx(styles.container)
    }, _react.default.createElement("div", {
      "aria-labelledby": labelID,
      className: cx(!disabled && underlined && styles.underlined),
      onMouseEnter: this.handleEnter,
      onMouseLeave: this.handleClose,
      onMouseDown: this.handleMouseDown
    }, children), _react.default.createElement("div", {
      id: labelID,
      className: cx(styles.offscreen)
    }, content), _react.default.createElement(_Overlay.default, {
      noBackground: true,
      open: open,
      onClose: this.handleClose
    }, _react.default.createElement("div", {
      ref: this.handleTooltipRef,
      role: "tooltip",
      className: cx(styles.tooltip, above ? styles.tooltip_above : styles.tooltip_below, {
        width,
        marginLeft: marginLeft[align],
        marginTop: above ? -(tooltipHeight + targetRect.height + distance) : distance,
        textAlign: align
      })
    }, _react.default.createElement("div", {
      className: cx(styles.shadow)
    }, _react.default.createElement(_NotchedBox.default, {
      inverted: !inverted,
      notchOffset: notchOffset[align],
      notchBelow: above
    }, _react.default.createElement(_Text.default, {
      inverted: !inverted
    }, content))))));
  }

}

exports.Tooltip = Tooltip;

_defineProperty(Tooltip, "propTypes", {
  width: _propTypes.default.number,
  content: _propTypes.default.any.isRequired,
  children: _propTypes.default.any.isRequired,
  disabled: _propTypes.default.bool,
  inverted: _propTypes.default.bool,
  remainOnMouseDown: _propTypes.default.bool,
  underlined: _propTypes.default.bool,
  onShow: _propTypes.default.func
});

_defineProperty(Tooltip, "defaultProps", {
  disabled: false,
  inverted: false,

  onShow() {},

  remainOnMouseDown: false,
  underlined: false,
  width: 35
});

var _default = (0, _withStyles.default)(_styles.styleSheet, {
  passThemeProp: true
})(Tooltip);

exports.default = _default;