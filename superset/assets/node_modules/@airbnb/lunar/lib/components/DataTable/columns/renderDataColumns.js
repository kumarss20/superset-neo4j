"use strict";

exports.__esModule = true;
exports.default = renderDataColumns;

var _react = _interopRequireDefault(require("react"));

var _reactVirtualized = require("react-virtualized");

var _DefaultRenderer = _interopRequireDefault(require("../DefaultRenderer"));

var _Spacing = _interopRequireDefault(require("../../Spacing"));

var _constants = require("../constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function renderDataColumns(keys, editMode, onEdit, cache, _ref) {
  let {
    columnMetadata,
    expandable,
    renderers,
    selectable,
    showColumnDividers,
    zebra,
    dynamicRowHeight,
    cx,
    styles,
    theme
  } = _ref;

  const renderCell = (key, columnIndex, row) => {
    const {
      metadata
    } = row.rowData;
    const {
      isChild
    } = metadata;
    const customRenderer = renderers && renderers[key];
    const isLeftmost = columnIndex === 0;
    const indentSize = !expandable || !isLeftmost ? 2 : 2.5;
    const spacing = isChild || !((expandable || selectable) && isLeftmost) ? indentSize : 0;
    const rendererArguments = {
      row,
      keyName: key,
      onEdit,
      zebra: zebra || false,
      editMode,
      theme
    };

    if (metadata && metadata.colSpanKey && renderers) {
      if (isLeftmost) {
        const colSpanRenderer = renderers[metadata.colSpanKey];

        if (colSpanRenderer) {
          return _react.default.createElement(colSpanRenderer, rendererArguments);
        }
      }
    }

    const contents = _react.default.createElement(customRenderer || _DefaultRenderer.default, rendererArguments);

    return _react.default.createElement(_Spacing.default, {
      left: spacing,
      right: 2
    }, contents || '');
  };

  const columnCellRenderer = columnIdx => row => {
    const {
      dataKey,
      parent,
      rowIndex
    } = row;
    const content = renderCell(dataKey, columnIdx, row);

    if (!dynamicRowHeight) {
      return _react.default.createElement("div", {
        className: cx(styles.rowContainer)
      }, _react.default.createElement("div", {
        className: cx(styles.row)
      }, content));
    }

    return _react.default.createElement("div", {
      className: cx(styles.rowContainer)
    }, _react.default.createElement(_reactVirtualized.CellMeasurer, {
      key: dataKey,
      cache: cache,
      columnIndex: columnIdx // @ts-ignore We need to pass in the parent node
      ,
      parent: parent,
      rowIndex: rowIndex
    }, _react.default.createElement("div", {
      className: cx(styles.row)
    }, content)));
  };

  return keys.map((key, idx) => {
    const widthPropertiesOptions = ['maxWidth', 'minWidth', 'width', 'flexGrow', 'flexShrink'];
    const widthProperties = {};
    widthPropertiesOptions.forEach(property => {
      widthProperties[property] = columnMetadata && columnMetadata[key] !== undefined && columnMetadata[key][property] !== undefined ? columnMetadata[key][property] : _constants.DEFAULT_WIDTH_PROPERTIES[property];
    });
    const isRightmost = idx === keys.length - 1;
    return _react.default.createElement(_reactVirtualized.Column, {
      key: key,
      dataKey: key,
      label: key,
      width: widthProperties.width,
      flexGrow: widthProperties.flexGrow,
      flexShrink: widthProperties.flexShrink,
      maxWidth: widthProperties.maxWidth,
      minWidth: widthProperties.minWidth,
      cellRenderer: columnCellRenderer(idx),
      className: cx(styles && styles.column, showColumnDividers && !isRightmost && styles && styles.column_divider)
    });
  });
}