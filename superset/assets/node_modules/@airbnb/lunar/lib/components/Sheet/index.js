"use strict";

exports.__esModule = true;
exports.default = Sheet;
exports.BaseSheet = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _IconClose = _interopRequireDefault(require("@airbnb/lunar-icons/lib/interface/IconClose"));

var _withStyles = _interopRequireDefault(require("../../composers/withStyles"));

var _keys = require("../../keys");

var _focusableSelector = _interopRequireDefault(require("../../utils/focusableSelector"));

var _FocusTrap = _interopRequireDefault(require("../FocusTrap"));

var _IconButton = _interopRequireDefault(require("../IconButton"));

var _Portal = _interopRequireDefault(require("../Portal"));

var _Row = _interopRequireDefault(require("../Row"));

var _Spacing = _interopRequireDefault(require("../Spacing"));

var _Translate = _interopRequireDefault(require("../Translate"));

var _SheetArea = _interopRequireDefault(require("./SheetArea"));

exports.SheetArea = _SheetArea.default;

var _SheetContext = _interopRequireDefault(require("./SheetContext"));

exports.SheetContext = _SheetContext.default;

var _styles = require("./styles");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** @ignore */
class BaseSheet extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "lastActiveElement", null);

    _defineProperty(this, "openTimeout", 0);

    _defineProperty(this, "sheetRef", _react.default.createRef());

    _defineProperty(this, "wrapperRef", _react.default.createRef());

    _defineProperty(this, "state", {
      animating: false
    });

    _defineProperty(this, "handleAnimationEnd", event => {
      const {
        gap
      } = this.props;

      if (!gap && event.target !== this.sheetRef.current || gap && event.target !== this.wrapperRef.current) {
        return;
      }

      this.setState({
        animating: false
      }); // If we're animating out, then we defered the visible reset call, so let's make it now:

      if (!this.props.portal && !this.props.visible) {
        this.props.setSheetVisible(false);
      }
    });

    _defineProperty(this, "handleKeyDown", event => {
      if (this.props.portal && event.key === _keys.ESCAPE) {
        this.props.onClose();
        event.stopPropagation();
      }
    });

    _defineProperty(this, "handleClose", () => {
      this.props.onClose();
    });
  }

  componentDidMount() {
    if (this.props.visible) {
      this.visibilityChange();
    }
  }

  componentDidUpdate(prevProps) {
    if (prevProps.visible !== this.props.visible) {
      this.visibilityChange();
    }
  }

  componentWillUnmount() {
    this.cleanupPortal();
  }

  cleanupPortal() {
    if (this.openTimeout) {
      window.clearTimeout(this.openTimeout);
    }

    document.removeEventListener('keydown', this.handleKeyDown);
    document.body.style.overflow = '';
  }

  visibilityChange() {
    const {
      noAnimation,
      portal,
      visible
    } = this.props;
    this.setState({
      animating: !noAnimation
    });

    if (visible && !portal) {
      this.props.setSheetVisible(visible);
    } // Custom portal logic:


    if (portal) {
      if (visible) {
        document.addEventListener('keydown', this.handleKeyDown);
        document.body.style.overflow = 'hidden';
        this.lastActiveElement = document.activeElement; // NOTE: Putting this in a setTimeout helps screen readers notice that focus has changed:

        this.openTimeout = window.setTimeout(() => {
          this.openTimeout = 0;

          if (this.sheetRef.current) {
            const firstFocusableElement = this.sheetRef.current.querySelector(_focusableSelector.default);

            if (firstFocusableElement) {
              firstFocusableElement.focus();
            }
          }
        }, 0);
      } else {
        this.cleanupPortal();

        if (this.lastActiveElement) {
          this.lastActiveElement.focus();
          this.lastActiveElement = null;
        }
      }
    }
  }

  render() {
    const {
      animating
    } = this.state;
    const {
      cx,
      gap,
      theme,
      styles,
      portal,
      visible,
      children,
      header,
      compact,
      headerShadow
    } = this.props;

    if (!visible && !animating) {
      return null;
    }

    const closeText = _Translate.default.phrase('Close', {}, {
      context: 'Close a sheet popup',
      key: 'lunar.common.close'
    });

    const closeIcon = _react.default.createElement(_IconButton.default, {
      onClick: this.handleClose
    }, _react.default.createElement(_IconClose.default, {
      accessibilityLabel: closeText,
      size: 3 * theme.unit
    }));

    const sheetContent = _react.default.createElement("div", {
      ref: this.sheetRef,
      "aria-modal": true,
      role: "dialog",
      className: cx(styles.sheet, portal && styles.sheet_portal, !gap && animating && styles.sheet_animating, !gap && animating && !visible && styles.sheet_out, !gap && animating && visible && styles.sheet_in),
      onAnimationEnd: this.handleAnimationEnd
    }, _react.default.createElement(_FocusTrap.default, {
      disabled: !portal
    }, _react.default.createElement("div", {
      className: cx(styles.container, gap && styles.container_gap, portal && animating && styles.container_animating)
    }, gap && _react.default.createElement("button", {
      className: cx(styles.gap),
      "aria-label": closeText,
      type: "button",
      onClick: this.handleClose
    }), _react.default.createElement("div", {
      ref: this.wrapperRef,
      className: cx(styles.wrapper, gap && styles.wrapper_gap, gap && animating && styles.sheet_animating, gap && animating && !visible && styles.sheet_slide_out, gap && animating && visible && styles.sheet_slide_in),
      onAnimationEnd: this.handleAnimationEnd
    }, _react.default.createElement("div", {
      className: cx(headerShadow && styles.headerShadow)
    }, _react.default.createElement(_Spacing.default, {
      all: compact ? 1 : 4,
      bottom: 0
    }, _react.default.createElement(_Row.default, {
      middleAlign: true,
      before: !gap && closeIcon,
      after: gap && closeIcon
    }, header || ''))), _react.default.createElement("div", {
      className: cx(styles.content, compact && styles.content_compact)
    }, children)))));

    if (portal) {
      return _react.default.createElement(_Portal.default, null, sheetContent);
    }

    return sheetContent;
  }

}

exports.BaseSheet = BaseSheet;

_defineProperty(BaseSheet, "propTypes", {
  children: _propTypes.default.any.isRequired,
  compact: _propTypes.default.bool,
  gap: _propTypes.default.bool,
  header: _propTypes.default.node,
  headerShadow: _propTypes.default.bool,
  noAnimation: _propTypes.default.bool,
  onClose: _propTypes.default.func.isRequired,
  portal: _propTypes.default.bool,
  visible: _propTypes.default.bool,
  setSheetVisible: _propTypes.default.any.isRequired
});

_defineProperty(BaseSheet, "defaultProps", {
  gap: false,
  noAnimation: false,
  portal: false,
  visible: false
});

const InternalSheet = (0, _withStyles.default)(_styles.styleSheet, {
  passThemeProp: true
})(BaseSheet);
/**
 * A modal-like UI that is used to display content in a sheet that covers the existing UI. There are
 * two versions of the Sheet: one that displays inline, and one that displays in a portal.

 * If you want to display a sheet inline, you must wrap the `Sheet` component in the exported
 * `SheetArea`. The wrapping component ensures that the positioning and scroll of the nested content
 * and sheet works as expected.

 * If you want to display a sheet in a portal, you can simply pass the `portal` prop to the `Sheet`
 * component, and it will render at the root of your document. It does not need to be wrapped in a
 * `SheetArea`.
 */

function Sheet(props) {
  return _react.default.createElement(_SheetContext.default.Consumer, null, setSheetVisible => _react.default.createElement(InternalSheet, _extends({}, props, {
    setSheetVisible: setSheetVisible
  })));
}

Sheet.propTypes = {
  children: _propTypes.default.any.isRequired,
  compact: _propTypes.default.bool,
  gap: _propTypes.default.bool,
  header: _propTypes.default.node,
  headerShadow: _propTypes.default.bool,
  noAnimation: _propTypes.default.bool,
  onClose: _propTypes.default.func.isRequired,
  portal: _propTypes.default.bool,
  visible: _propTypes.default.bool
};