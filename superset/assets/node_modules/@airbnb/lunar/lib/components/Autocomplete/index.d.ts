import React from 'react';
import { Props as BaseInputProps } from '../private/BaseInput';
import { Props as FormFieldProps } from '../FormField';
import { RenderableProp } from '../../utils/renderElementOrFunction';
export declare type Item = {
    disabled?: boolean;
    href?: string;
    id?: string | number;
    name?: string;
    title?: string;
    value?: string | number;
};
export declare const CACHE_DURATION: number;
declare function getItemValue(item: Item): string;
declare function renderItem(item: Item): NonNullable<React.ReactNode>;
export declare type ItemResponseType<T> = T[] | {
    items?: T[];
    results?: T[];
};
export declare type Props<T extends Item = Item> = Omit<BaseInputProps, 'id'> & FormFieldProps & {
    /** Accessibility label. */
    accessibilityLabel: string;
    /** Auto-focus the input field on mount. */
    autoFocus?: boolean;
    /** Content to display below the input. */
    children?: React.ReactNode;
    /** Clear input field when an item is selected. */
    clearOnSelect?: boolean;
    /** Delay in which to load items. */
    debounce?: number;
    /** Disable caching of loaded item responses. */
    disableCache?: boolean;
    /**
     * Value to insert into the input field when an item is selected.
     * Defaults to the item's `value` or `id` property.
     */
    getItemValue?: (item: T) => string;
    /** Determine if an item is selectable. Non-selectable items will be disabled in the list. */
    isItemSelectable?: (item: T, selected?: boolean) => boolean;
    /** Determine if an item is selected. Will compare values by default if not defined. */
    isItemSelected?: (item: T, value: string) => boolean;
    /** Load and show items with the current value when focused. */
    loadItemsOnFocus?: boolean;
    /** Load and show items on mount. */
    loadItemsOnMount?: boolean;
    /** Max height of the results dropdown menu. */
    maxHeight?: number;
    /** Message to display when no items are found. */
    noResultsText?: React.ReactNode;
    /** Callback fired when the value changes. */
    onChange: (value: string, event: React.SyntheticEvent<HTMLElement>) => void;
    /** Callback fired to load items. Must return a promise with an array of items. */
    onLoadItems: (value: string) => Promise<ItemResponseType<T>>;
    /** Callback fired when the display of the menu is toggled. */
    onMenuVisibilityChange?: (open: boolean) => void;
    /**
     * Callback fired when an item is selected.
     * When a field is reset, item is passed `null` and no event is passed.
     */
    onSelectItem?: (value: string, item: T | null, event?: React.SyntheticEvent<HTMLElement>) => void;
    /** Placeholder within the search input. */
    placeholder?: string;
    /** Render an error when items fail to load. */
    renderError?: RenderableProp<Error>;
    /** Render the content within a menu item. */
    renderItem?: (item: T, highlighted: boolean, selected: boolean) => NonNullable<React.ReactNode>;
    /** Render a loading state while items are loading. */
    renderLoading?: RenderableProp;
    /** Render a no results state while items are empty. */
    renderNoResults?: RenderableProp;
    /**
     * Function in which to determine if an item should render in the menu.
     * This should be used for item list filtering.
     */
    shouldItemRender?: (item: T, value: string) => boolean;
};
export declare type State<T extends Item = Item> = {
    error: Error | null;
    highlightedIndex: number | null;
    id: string;
    items: T[];
    loading: boolean;
    open: boolean;
    value: string;
};
/** An uncontrolled input field that utilizes a search lookup for automatic completion. */
export default class Autocomplete<T extends Item = Item> extends React.Component<Props<T>, State<T>> {
    static defaultProps: {
        autoFocus: boolean;
        clearOnSelect: boolean;
        debounce: number;
        disableCache: boolean;
        getItemValue: typeof getItemValue;
        isItemSelectable: () => boolean;
        isItemSelected: () => boolean;
        loadItemsOnFocus: boolean;
        loadItemsOnMount: boolean;
        onMenuVisibilityChange(): void;
        onSelectItem(): void;
        renderItem: typeof renderItem;
    };
    cache: {
        [query: string]: {
            items: T[];
            time: number;
        };
    };
    ignoreBlur: boolean;
    ignoreFocus: boolean;
    inputRef: React.RefObject<HTMLInputElement>;
    state: State<T>;
    componentDidMount(): void;
    componentDidUpdate(prevProps: Props<T>, prevState: State<T>): void;
    focusInput: () => void;
    private handleInputBlur;
    private handleInputChange;
    private handleInputClick;
    private handleInputFocus;
    private handleInputKeyDown;
    private handleInputKeyDownArrowDown;
    private handleInputKeyDownArrowUp;
    private handleInputKeyDownEnter;
    private handleInputKeyDownEscape;
    private handleInputKeyDownTab;
    private handleItemMouseEnter;
    private handleItemMouseDown;
    private handleSelect;
    getFilteredItems(state: State<T>): T[];
    getInputProps(props: Props<T>): {
        compact: boolean | undefined;
        disabled: boolean | undefined;
        id: string;
        invalid: boolean | undefined;
        name: string | undefined;
        onBlur: ((event: React.FocusEvent<HTMLInputElement>) => void) | undefined;
        onFocus: ((event: React.FocusEvent<HTMLInputElement>) => void) | undefined;
        optional: boolean | undefined;
        placeholder: string;
        small: boolean | undefined;
        type: string;
    };
    loadItems: (value: string, force?: boolean | undefined, callback?: (() => void) | undefined) => Promise<void | T[]>;
    loadItemsDebounced: (value: any) => Promise<{
        input: string;
        response: ItemResponseType<T>;
    }>;
    maybeAutoCompleteText: (state: State<T>) => void;
    setIgnoreBlur: (ignore: boolean) => void;
    renderError: (error: Error) => JSX.Element;
    renderItem: (item: T, highlighted?: boolean | undefined, selected?: boolean | undefined, props?: React.HTMLAttributes<HTMLDivElement> | undefined) => JSX.Element;
    renderItems: () => JSX.Element[];
    renderLoading: () => JSX.Element;
    renderMenu: () => JSX.Element;
    renderNoResults: () => JSX.Element;
    render(): JSX.Element;
}
export {};
//# sourceMappingURL=index.d.ts.map