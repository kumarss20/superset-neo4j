"use strict";

exports.__esModule = true;
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _throttle = _interopRequireDefault(require("lodash/throttle"));

var _debounce = _interopRequireDefault(require("lodash/debounce"));

var _isScrollable = require("../../utils/isScrollable");

var _Portal = _interopRequireDefault(require("./Portal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** An overlay that masks the entire viewport and displays a chunk of content over it. */
class Overlay extends _react.default.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      x: 0,
      y: 0
    });

    _defineProperty(this, "ref", _react.default.createRef());

    _defineProperty(this, "scrollers", []);

    _defineProperty(this, "addScrollListeners", (0, _debounce.default)(() => {
      const {
        current
      } = this.ref;
      this.removeScrollListeners();
      /* istanbul ignore next: refs are hard */

      if (current) {
        this.scrollers = (0, _isScrollable.scrollingParents)(current);
        this.scrollers.forEach(node => {
          node.addEventListener('scroll', this.handleScroll);
        });
      }
    }));

    _defineProperty(this, "removeScrollListeners", () => {
      this.scrollers.forEach(node => {
        node.removeEventListener('scroll', this.handleScroll);
      });
      this.scrollers = [];
    });

    _defineProperty(this, "handleResize", () => {
      this.forceUpdate();
    });

    _defineProperty(this, "handleScroll", (0, _throttle.default)(() => this.props.onClose(), 100));
  }

  componentDidUpdate() {
    const {
      current
    } = this.ref;
    /* istanbul ignore next: refs are hard */

    if (current) {
      const {
        x,
        y
      } = current.getBoundingClientRect();

      if (x !== this.state.x) {
        this.setState({
          x
        });
      }

      if (y !== this.state.y) {
        this.setState({
          y
        });
      }
    }

    this.removeScrollListeners();

    if (this.props.open && this.props.noBackground) {
      this.addScrollListeners();
    }
  }

  componentWillUnmount() {
    this.removeScrollListeners();
  }

  render() {
    const {
      onClose,
      open,
      children,
      noBackground
    } = this.props;
    const {
      x,
      y
    } = this.state;
    return _react.default.createElement("div", {
      ref: this.ref
    }, open && _react.default.createElement(_Portal.default, {
      x: x,
      y: y,
      noBackground: noBackground,
      onClose: onClose,
      onResize: this.handleResize
    }, children));
  }

}

exports.default = Overlay;

_defineProperty(Overlay, "propTypes", {
  children: _propTypes.default.node,
  open: _propTypes.default.bool,
  noBackground: _propTypes.default.bool,
  onClose: _propTypes.default.func.isRequired
});

_defineProperty(Overlay, "defaultProps", {
  noBackground: false,
  open: false
});