"use strict";

exports.__esModule = true;
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _keys = require("../../keys");

var _focusableSelector = _interopRequireDefault(require("../../utils/focusableSelector"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Automatically trap and apply focus to elements wrapped within. */
class FocusTrap extends _react.default.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "nodeRef", _react.default.createRef());

    _defineProperty(this, "handleKeyDown", event => {
      if (this.props.disabled || event.key !== _keys.TAB) {
        return;
      }

      const focusableElements = this.getFocusableElements();

      if (focusableElements.length === 0 || !document.activeElement) {
        return;
      }

      let focusIndex = focusableElements.indexOf(document.activeElement);
      const initialIndex = focusIndex;

      do {
        if (event.shiftKey) {
          if (focusIndex < 1) {
            // Currently focusing either the first element (focusIndex = 0),
            // or no element (focusIndex = -1), so jump to the last focusable element.
            focusIndex = focusableElements.length - 1;
          } else {
            focusIndex -= 1;
          }
        } else if (focusIndex === focusableElements.length - 1) {
          // Tabbing forward from end of trap, so jump to beginning.
          focusIndex = 0;
        } else {
          // Note that this also catches the case where focusIndex = -1,
          // in which case we focus index 0, which is the correct functionality.
          focusIndex += 1;
        }

        const element = focusableElements[focusIndex];

        if (element instanceof HTMLElement) {
          element.focus();
        } // On the off chance that we are able to begin tabbing in a trap with
        // only untabbable elements, we want to break out of an infinite loop.


        if (focusIndex === initialIndex) {
          break;
        } // Trying to focus on an element with e.g. display: none or visibility: hidden
        // will fail, so we need to find the next element to focus in that case.

      } while (document.activeElement !== focusableElements[focusIndex]);

      event.preventDefault();
    });
  }

  getFocusableElements() {
    if (!this.nodeRef.current) {
      return [];
    }

    return Array.from(this.nodeRef.current.querySelectorAll(_focusableSelector.default));
  }

  render() {
    return (// eslint-disable-next-line jsx-a11y/no-static-element-interactions
      _react.default.createElement("div", {
        ref: this.nodeRef,
        onKeyDown: this.handleKeyDown
      }, this.props.children)
    );
  }

}

exports.default = FocusTrap;

_defineProperty(FocusTrap, "propTypes", {
  children: _propTypes.default.any.isRequired,
  disabled: _propTypes.default.bool
});

_defineProperty(FocusTrap, "defaultProps", {
  disabled: false
});