"use strict";

exports.__esModule = true;
exports.default = exports.ScrollWrapper = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _withStyles = _interopRequireDefault(require("../../composers/withStyles"));

var _ScrollContext = _interopRequireDefault(require("./ScrollContext"));

var _styles = require("./styles");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Wrapper that measures location of `ScrollSection`s. */
class ScrollWrapper extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "anchors", new Map());

    _defineProperty(this, "observer", null);

    _defineProperty(this, "scrollContext", void 0);

    _defineProperty(this, "scrollRef", _react.default.createRef());

    _defineProperty(this, "addScrollAnchor", (name, anchor) => {
      if ("production" !== process.env.NODE_ENV && this.anchors.has(name)) {
        throw new Error("Duplicate anchor id added: " + name);
      }

      if (this.observer) {
        this.observer.observe(anchor);
      }

      this.anchors.set(name, anchor);
    });

    _defineProperty(this, "removeScrollAnchor", name => {
      // Since we always clear anchor before adding a new one,
      // we do not want to break when we have not added an anchor yet.
      if (!this.anchors.has(name)) {
        return;
      }

      if (this.observer) {
        this.observer.unobserve(this.anchors.get(name));
      }

      this.anchors.delete(name);
    });

    _defineProperty(this, "handleIntersect",
    /* istanbul ignore next */
    entries => {
      entries.forEach((_ref) => {
        let {
          target,
          isIntersecting
        } = _ref;

        // isIntersecting is true if it has passed the threshold in a positive direction,
        // false if it is no longer intersecting, this is preferable to using intersectionRatio
        // as on small intersection areas, the ratio can lose precision wnough to be 0,
        // rather than a very small number.
        if (isIntersecting && this.props.onChangeActiveScrollSection) {
          this.props.onChangeActiveScrollSection(target.id);
        }

        if (!isIntersecting && this.props.onHideScrollSection) {
          this.props.onHideScrollSection(target.id);
        }
      });
    });
  }

  componentDidMount() {
    if (this.scrollRef.current) {
      this.setupObserver();
    }
  }

  componentDidUpdate(prevProps) {
    if (this.props.intersectionMargin !== prevProps.intersectionMargin) {
      this.setupObserver();
    }
  }

  setupObserver() {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }

    if (this.scrollRef.current) {
      this.observer = new IntersectionObserver(this.handleIntersect, {
        root: this.scrollRef.current,
        rootMargin: this.props.intersectionMargin,
        threshold: this.props.intersectionThreshold
      });
      this.anchors.forEach(anchor => {
        this.observer.observe(anchor);
      });
    }
  }

  render() {
    const {
      cx,
      children,
      styles
    } = this.props;

    if (!this.scrollContext) {
      this.scrollContext = {
        addScrollAnchor: this.addScrollAnchor,
        removeScrollAnchor: this.removeScrollAnchor
      };
    }

    return _react.default.createElement(_ScrollContext.default.Provider, {
      value: this.scrollContext
    }, _react.default.createElement("div", {
      ref: this.scrollRef,
      className: cx(styles.wrapper)
    }, children));
  }

}

exports.ScrollWrapper = ScrollWrapper;

_defineProperty(ScrollWrapper, "propTypes", {
  children: _propTypes.default.any.isRequired,
  intersectionMargin: _propTypes.default.string,
  intersectionThreshold: _propTypes.default.number,
  onChangeActiveScrollSection: _propTypes.default.func,
  onHideScrollSection: _propTypes.default.func
});

_defineProperty(ScrollWrapper, "defaultProps", {
  intersectionMargin: '0% 0% -99% 0%'
});

var _default = (0, _withStyles.default)(_styles.styleSheetScrollWrapper)(ScrollWrapper);

exports.default = _default;