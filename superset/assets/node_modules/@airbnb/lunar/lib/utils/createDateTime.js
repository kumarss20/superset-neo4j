"use strict";

exports.__esModule = true;
exports.default = createDateTime;

var _luxon = require("luxon");

exports.DateTime = _luxon.DateTime;

var _ = _interopRequireDefault(require(".."));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const clientLocale = _.default.locale();

const clientZone = new _luxon.IANAZone(_.default.timezone());
const utcZone = new _luxon.IANAZone('UTC');

function createDateTime(value, _temp) {
  let {
    locale,
    sourceFormat,
    timezone
  } = _temp === void 0 ? {} : _temp;
  const options = {
    locale: locale || clientLocale
  };
  let date;

  if (timezone === false) {
    options.zone = utcZone;
  } else if (timezone === true) {
    options.zone = clientZone;
  } else {
    options.zone = timezone || clientZone;
  } // Support moment objects for backwards compat
  // eslint-disable-next-line @typescript-eslint/no-explicit-any


  const moment = value;

  if (moment && typeof moment === 'object' && '_isAMomentObject' in moment) {
    return _luxon.DateTime.fromISO(moment.toISOString(), options);
  } // Parse in different formats


  if (value instanceof _luxon.DateTime) {
    date = value.setLocale(options.locale).setZone(options.zone);
  } else if (value instanceof Date) {
    date = _luxon.DateTime.fromJSDate(value, options);
  } else if (typeof value === 'string' && value) {
    date = sourceFormat ? _luxon.DateTime.fromFormat(value, sourceFormat, options) : _luxon.DateTime.fromISO(value, options);
  } else if (typeof value === 'number') {
    date = _luxon.DateTime.fromMillis(value, options);
  } else {
    date = _luxon.DateTime.utc().setLocale(options.locale);

    if (options.zone !== 'UTC') {
      date = date.setZone(options.zone);
    }
  }

  return date;
}