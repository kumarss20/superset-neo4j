import _pt from "prop-types";

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React from 'react';
import Parser from './Parser';
import Markup from './Markup';
export default function Interweave(props) {
  var _props$content = props.content,
      content = _props$content === void 0 ? '' : _props$content,
      _props$disableFilters = props.disableFilters,
      disableFilters = _props$disableFilters === void 0 ? false : _props$disableFilters,
      _props$disableMatcher = props.disableMatchers,
      disableMatchers = _props$disableMatcher === void 0 ? false : _props$disableMatcher,
      _props$emptyContent = props.emptyContent,
      emptyContent = _props$emptyContent === void 0 ? null : _props$emptyContent,
      _props$filters = props.filters,
      filters = _props$filters === void 0 ? [] : _props$filters,
      _props$matchers = props.matchers,
      matchers = _props$matchers === void 0 ? [] : _props$matchers,
      _props$onAfterParse = props.onAfterParse,
      onAfterParse = _props$onAfterParse === void 0 ? null : _props$onAfterParse,
      _props$onBeforeParse = props.onBeforeParse,
      onBeforeParse = _props$onBeforeParse === void 0 ? null : _props$onBeforeParse,
      _props$tagName = props.tagName,
      tagName = _props$tagName === void 0 ? 'span' : _props$tagName,
      parserProps = _objectWithoutPropertiesLoose(props, ["content", "disableFilters", "disableMatchers", "emptyContent", "filters", "matchers", "onAfterParse", "onBeforeParse", "tagName"]);

  var allMatchers = disableMatchers ? [] : matchers;
  var allFilters = disableFilters ? [] : filters;
  var beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];
  var afterCallbacks = onAfterParse ? [onAfterParse] : [];
  allMatchers.forEach(function (matcher) {
    if (matcher.onBeforeParse) {
      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));
    }

    if (matcher.onAfterParse) {
      afterCallbacks.push(matcher.onAfterParse.bind(matcher));
    }
  });
  var markup = beforeCallbacks.reduce(function (string, callback) {
    var nextString = callback(string, props);

    if ("production" !== process.env.NODE_ENV) {
      if (typeof nextString !== 'string') {
        throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');
      }
    }

    return nextString;
  }, content || '');
  var parser = new Parser(markup, parserProps, allMatchers, allFilters);
  var nodes = afterCallbacks.reduce(function (parserNodes, callback) {
    var nextNodes = callback(parserNodes, props);

    if ("production" !== process.env.NODE_ENV) {
      if (!Array.isArray(nextNodes)) {
        throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');
      }
    }

    return nextNodes;
  }, parser.parse());
  return React.createElement(Markup, {
    emptyContent: emptyContent,
    tagName: tagName,
    parsedContent: nodes.length === 0 ? undefined : nodes
  });
}
Interweave.propTypes = {
  disableFilters: _pt.bool,
  disableMatchers: _pt.bool,
  filters: _pt.arrayOf(_pt.any),
  matchers: _pt.arrayOf(_pt.any),
  onAfterParse: _pt.oneOfType([_pt.any, _pt.oneOf([null])]),
  onBeforeParse: _pt.oneOfType([_pt.any, _pt.oneOf([null])])
};