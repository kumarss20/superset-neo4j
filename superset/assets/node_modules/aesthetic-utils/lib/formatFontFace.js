"use strict";

exports.__esModule = true;
exports.default = formatFontFace;

var _toArray = _interopRequireDefault(require("./toArray"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var FORMATS = {
  '.eot': 'embedded-opentype',
  '.otf': 'opentype',
  '.svg': 'svg',
  '.svgz': 'svg',
  '.ttf': 'truetype',
  '.woff': 'woff',
  '.woff2': 'woff2'
};

function formatFontFace(properties) {
  var fontFace = _extends({}, properties);

  var src = [];

  if (fontFace.local) {
    (0, _toArray.default)(fontFace.local).forEach(function (alias) {
      src.push("local('" + String(alias) + "')");
    });
    delete fontFace.local;
  }

  if (Array.isArray(fontFace.srcPaths)) {
    (0, _toArray.default)(fontFace.srcPaths).forEach(function (srcPath) {
      var ext = srcPath.slice(srcPath.lastIndexOf('.'));

      if (ext.includes('?')) {
        var _ext$split = ext.split('?');

        ext = _ext$split[0];
      }

      if (FORMATS[ext]) {
        src.push("url('" + srcPath + "') format('" + FORMATS[ext] + "')");
      } else if ("production" !== process.env.NODE_ENV) {
        throw new Error("Unsupported font format \"" + ext + "\".");
      }
    });
    delete fontFace.srcPaths;
  } else {
    return fontFace;
  }

  fontFace.src = src.join(', ');
  return fontFace;
}