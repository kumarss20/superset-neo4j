function _extends(){return _extends=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends.apply(this,arguments)}function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function _inheritsLoose(a,b){a.prototype=Object.create(b.prototype),a.prototype.constructor=a,a.__proto__=b}/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */ /* eslint-disable sort-keys, no-magic-numbers, react/forbid-prop-types */ /* eslint-disable react/require-default-props */import React from"react";import PropTypes from"prop-types";import MapGL from"react-map-gl";import Immutable from"immutable";import ViewportMercator from"viewport-mercator-project";import ScatterPlotGlowOverlay from"./ScatterPlotGlowOverlay";import"./MapBox.css";var NOOP=function(){};export var DEFAULT_MAX_ZOOM=16;export var DEFAULT_POINT_RADIUS=60;var propTypes={width:PropTypes.number,height:PropTypes.number,aggregatorName:PropTypes.string,clusterer:PropTypes.object,globalOpacity:PropTypes.number,hasCustomMetric:PropTypes.bool,mapStyle:PropTypes.string,mapboxApiKey:PropTypes.string.isRequired,onViewportChange:PropTypes.func,pointRadius:PropTypes.number,pointRadiusUnit:PropTypes.string,renderWhileDragging:PropTypes.bool,rgb:PropTypes.array,bounds:PropTypes.array},defaultProps={width:400,height:400,globalOpacity:1,onViewportChange:NOOP,pointRadius:DEFAULT_POINT_RADIUS,pointRadiusUnit:"Pixels"},MapBox=/*#__PURE__*/function(a){function b(b){var c=a.call(this,b)||this;var d=c.props,e=d.width,f=d.height,g=d.bounds,h=new ViewportMercator({width:e,height:f}).fitBounds(g),i=h.latitude,j=h.longitude,k=h.zoom;// Get a viewport that fits the given bounds, which all marks to be clustered.
// Derive lat, lon and zoom from this viewport. This is only done on initial
// render as the bounds don't update as we pan/zoom in the current design.
return c.state={viewport:{longitude:j,latitude:i,zoom:k}},c.handleViewportChange=c.handleViewportChange.bind(_assertThisInitialized(c)),c}_inheritsLoose(b,a);var c=b.prototype;return c.handleViewportChange=function handleViewportChange(a){this.setState({viewport:a});var b=this.props.onViewportChange;b(a)},c.render=function render(){var a=this.props,b=a.width,c=a.height,d=a.aggregatorName,e=a.clusterer,f=a.globalOpacity,g=a.mapStyle,h=a.mapboxApiKey,i=a.pointRadius,j=a.pointRadiusUnit,k=a.renderWhileDragging,l=a.rgb,m=a.hasCustomMetric,n=a.bounds,o=this.state.viewport,p=void 0!==o.isDragging&&o.isDragging,q=[n[0][0],n[0][1],n[1][0],n[1][1]],r=e.getClusters(q,Math.round(o.zoom));return React.createElement(MapGL,_extends({},o,{mapStyle:g,width:b,height:c,mapboxApiAccessToken:h,onViewportChange:this.handleViewportChange}),React.createElement(ScatterPlotGlowOverlay,_extends({},o,{isDragging:p,locations:Immutable.fromJS(r),dotRadius:i,pointRadiusUnit:j,rgb:l,globalOpacity:f,compositeOperation:"screen",renderWhileDragging:k,aggregation:m?d:null,lngLatAccessor:function lngLatAccessor(a){var b=a.get("geometry").get("coordinates");return[b.get(0),b.get(1)]}})))},b}(React.Component);MapBox.propTypes=propTypes,MapBox.defaultProps=defaultProps;export default MapBox;