import { MetricKey, AdhocMetric } from './Metric';
import { TimeRange } from './Time';
import { AdhocFilter } from './Filter';
export declare type QueryFormDataMetric = string | AdhocMetric;
export declare type QueryFormDataMetrics = Partial<Record<MetricKey, QueryFormDataMetric | QueryFormDataMetric[]>>;
export declare type BaseFormData = {
    /** datasource identifier ${id}_${type} */
    datasource: string;
    /**
     * visualization type
     * - necessary if you use the plugin and want to use
     * buildQuery function from the plugin.
     * This must match the key used when registering the plugin.
     * - not necessary if you do not plan to use the
     * buildQuery function from the plugin.
     * Can put "custom" (or any string) in this field in that case.
     */
    viz_type: string;
    /** list of columns to group by */
    groupby?: string[];
    where?: string;
    columns?: string[];
    all_columns?: string[];
    /** list of filters */
    adhoc_filters?: AdhocFilter[];
    /** order descending */
    order_desc?: boolean;
    /** limit number of time series */
    limit?: number;
    /** limit number of row in the results */
    row_limit?: number;
    /** The metric used to order timeseries for limiting */
    timeseries_limit_metric?: QueryFormDataMetric;
} & TimeRange & QueryFormDataMetrics;
export declare type SqlaFormData = {
    granularity_sqla: string;
    time_grain_sqla?: string;
    having?: string;
} & BaseFormData;
export declare type DruidFormData = {
    granularity: string;
    having_druid?: string;
    druid_time_origin?: string;
} & BaseFormData;
export declare type QueryFormData = SqlaFormData | DruidFormData;
export declare function isDruidFormData(formData: QueryFormData): formData is DruidFormData;
export declare function isSqlaFormData(formData: QueryFormData): formData is SqlaFormData;
