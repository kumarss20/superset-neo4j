function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}function _extends(){return _extends=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends.apply(this,arguments)}/* eslint-disable no-magic-numbers */import React from"react";import{getTextDimension}from"@superset-ui/dimension";import{CategoricalColorScale}from"@superset-ui/color";import{extractFormatFromTypeAndFormat}from"./parsers/extractFormat";import{DEFAULT_LABEL_ANGLE}from"../utils/constants";var DEFAULT_BASE_CONFIG={labelOverlap:"auto",labelPadding:4,tickCount:5},DEFAULT_X_CONFIG=_extends({},DEFAULT_BASE_CONFIG,{labelAngle:DEFAULT_LABEL_ANGLE,orient:"bottom"}),DEFAULT_Y_CONFIG=_extends({},DEFAULT_BASE_CONFIG,{labelAngle:0,orient:"left"}),AxisAgent=/*#__PURE__*/function(){function a(a){_defineProperty(this,"channelEncoder",void 0),_defineProperty(this,"format",void 0),_defineProperty(this,"config",void 0),this.channelEncoder=a;var b=a.definition,c=b.type,d=b.axis,e=void 0===d?{}:d;this.config=this.channelEncoder.isX()?_extends({},DEFAULT_X_CONFIG,{},e):_extends({},DEFAULT_Y_CONFIG,{},e),"undefined"!=typeof e.format&&(this.format=extractFormatFromTypeAndFormat(c,e.format))}var b=a.prototype;return b.getFormat=function getFormat(){return this.format||this.channelEncoder.formatValue},b.hasTitle=function hasTitle(){return""!==this.getTitle()},b.getTitle=function getTitle(){var a=this.config.title;return void 0===a||!0===a?this.channelEncoder.getTitle():!1===a||""===a?"":a},b.getTickLabels=function getTickLabels(){var a=this.config,b=a.tickCount,c=a.values,d=this.getFormat();if("undefined"!=typeof c)return c.map(d);if("undefined"!=typeof this.channelEncoder.scale){var e=this.channelEncoder.scale.scale;if("undefined"!=typeof e&&!(e instanceof CategoricalColorScale))return("ticks"in e&&"undefined"!=typeof e.ticks?e.ticks(b):e.domain()).map(d)}return[]}// eslint-disable-next-line complexity
,b.computeLayout=function computeLayout(a){var b,c=a.axisTitleHeight,d=void 0===c?20:c,e=a.axisWidth,f=a.gapBetweenAxisLabelAndBorder,g=void 0===f?4:f,h=a.gapBetweenTickAndTickLabel,i=void 0===h?4:h,j=a.labelAngle,k=void 0===j?this.config.labelAngle:j,l=a.tickSize,m=void 0===l?8:l,n=a.tickTextStyle,o=void 0===n?{}:n,p=this.getTickLabels(),q=p.map(function(a){return getTextDimension({style:o,text:a})}),r=this.config,s=r.labelOverlap,t=r.labelPadding,u=r.orient,v=Math.max.apply(Math,q.map(function(a){return a.width}).concat([0])),w=s;if("auto"===w){// cheap heuristic, can improve
var B=e/p.length;w=this.channelEncoder.isY()||v<=B?"flat":"rotate"}var x,y=this.hasTitle()?t+d:0,z=0,A=m+i+y+g;if(this.channelEncoder.isX()){if("flat"===w){var C=0<q.length?q[0].height:0;z=C+t,A+=C}else if("rotate"===w){var D=Math.ceil(Math.abs(v*Math.sin(k*Math.PI/180)));z=D+t,A+=D,x="top"===u&&0<k||"bottom"===u&&0>k?"end":"start"}A+=8}else z=v+y,A+=v;return{axisWidth:e,labelAngle:"flat"===w?0:k,labelFlush:"undefined"==typeof this.config.labelFlush?// If not set, only enable flushing for continuous scales
"continuous"===this.channelEncoder.scale.scaleTypeCategory:this.config.labelFlush,labelOffset:z,labelOverlap:w,minMargin:(b={},b[u]=Math.ceil(A),b),orient:u,tickLabelDimensions:q,tickLabels:p,tickTextAnchor:x}},a}();export{AxisAgent as default};