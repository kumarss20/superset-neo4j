import { ChannelType, AllChannelOptions } from './types/Channel';
import { FullSpec, BaseOptions, PartialSpec } from './types/Specification';
import { ChannelDef } from './types/ChannelDef';
import { Dataset } from './types/Data';
import { Unarray, MayBeArray } from './types/Base';
import ChannelEncoder from './ChannelEncoder';
declare type AllChannelEncoders<Encoding extends Record<string, MayBeArray<ChannelDef>>> = {
    readonly [k in keyof Encoding]: Encoding[k] extends any[] ? ChannelEncoder<Unarray<Encoding[k]>>[] : ChannelEncoder<Unarray<Encoding[k]>>;
};
export default abstract class AbstractEncoder<ChannelTypes extends Record<string, ChannelType>, Encoding extends Record<keyof ChannelTypes, MayBeArray<ChannelDef>>, Options extends BaseOptions = BaseOptions> {
    readonly spec: FullSpec<Encoding, Options>;
    readonly channelTypes: ChannelTypes;
    readonly channels: AllChannelEncoders<Encoding>;
    readonly legends: {
        [key: string]: (keyof Encoding)[];
    };
    constructor(channelTypes: ChannelTypes, spec: PartialSpec<Encoding, Options>, defaultEncoding?: Encoding, allChannelOptions?: AllChannelOptions<Encoding>);
    /**
     * subclass can override this
     */
    createFullSpec(spec: PartialSpec<Encoding, Options>, defaultEncoding?: Encoding): FullSpec<Encoding, Options>;
    getChannelNames(): (keyof ChannelTypes)[];
    getChannelsAsArray(): AllChannelEncoders<Encoding>[keyof ChannelTypes][];
    getGroupBys(): string[];
    getLegendInfos(data: Dataset): {
        field: string;
        value: string | number | boolean | Date | null | undefined;
        encodedValues: Partial<Record<keyof Encoding, string | number | boolean | null | undefined>>;
    }[][];
    hasLegend(): boolean;
}
export {};
