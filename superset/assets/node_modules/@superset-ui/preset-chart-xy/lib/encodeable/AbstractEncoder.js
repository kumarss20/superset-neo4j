"use strict";exports.__esModule=!0,exports.default=void 0;var _lodash=require("lodash"),_ChannelDef=require("./types/ChannelDef"),_Base=require("./types/Base"),_ChannelEncoder=_interopRequireDefault(require("./ChannelEncoder"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}function _objectWithoutPropertiesLoose(a,b){if(null==a)return{};var c,d,e={},f=Object.keys(a);for(d=0;d<f.length;d++)c=f[d],0<=b.indexOf(c)||(e[c]=a[c]);return e}function _extends(){return _extends=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends.apply(this,arguments)}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}var AbstractEncoder=/*#__PURE__*/function(){function a(a,b,c,d){var e=this;void 0===d&&(d={}),_defineProperty(this,"spec",void 0),_defineProperty(this,"channelTypes",void 0),_defineProperty(this,"channels",void 0),_defineProperty(this,"legends",void 0),this.channelTypes=a,this.spec=this.createFullSpec(b,c);var f=this.spec.encoding,g=this.getChannelNames(),h={};g.forEach(function(b){var c=f[b];if((0,_Base.isArray)(c)){h[b]=c.map(function(a,c){return new _ChannelEncoder.default({definition:a,name:b+"["+c+"]",type:"Text"})})}else if((0,_Base.isNotArray)(c)){h[b]=new _ChannelEncoder.default({definition:c,name:b,options:_extends({},e.spec.options,{},d[b]),type:a[b]})}}),this.channels=h,this.legends={},g.map(function(a){return e.channels[a]}).forEach(function(a){if((0,_Base.isNotArray)(a)&&a.hasLegend()&&(0,_ChannelDef.isFieldDef)(a.definition)){var b=a.name,c=a.definition.field;e.legends[c]?e.legends[c].push(b):e.legends[c]=[b]}})}/**
   * subclass can override this
   */var b=a.prototype;return b.createFullSpec=function createFullSpec(a,b){if("undefined"==typeof b)return a;var c=a.encoding,d=_objectWithoutPropertiesLoose(a,["encoding"]);return _extends({},d,{encoding:_extends({},b,{},c)})},b.getChannelNames=function getChannelNames(){return Object.keys(this.channelTypes)},b.getChannelsAsArray=function getChannelsAsArray(){var a=this;return this.getChannelNames().map(function(b){return a.channels[b]})},b.getGroupBys=function getGroupBys(){var a=(0,_lodash.flatMap)(this.getChannelsAsArray()).filter(function(a){return a.isGroupBy()}).map(function(a){return(0,_ChannelDef.isFieldDef)(a.definition)?a.definition.field:""}).filter(function(a){return""!==a});return Array.from(new Set(a))},b.getLegendInfos=function getLegendInfos(a){var b=this;return Object.keys(this.legends).map(function(c){var d=b.legends[c],e=b.channels[d[0]];if((0,_Base.isNotArray)(e)&&(0,_ChannelDef.isTypedFieldDef)(e.definition)&&"nominal"===e.definition.type)// Only work for nominal channels now
// TODO: Add support for numerical scale
{var f=e.getDomain(a);return f.map(function(a){return{field:c,value:a,// eslint-disable-next-line sort-keys
encodedValues:d.reduce(function(c,d){var e=c,f=b.channels[d];return(0,_Base.isNotArray)(f)&&(e[d]=f.encodeValue(a)),e},{})}})}return[]}).filter(function(a){return 0<a.length})},b.hasLegend=function hasLegend(){return 0<Object.keys(this.legends).length},a}();exports.default=AbstractEncoder;