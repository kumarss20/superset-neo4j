import { Value } from 'vega-lite/build/src/channeldef';
import { ChannelTypeToDefMap } from '../encodeable/types/Channel';
import { ExtractChannelOutput } from '../encodeable/types/ChannelDef';
/**
 * Define channel types
 */
declare const channelTypes: {
    readonly color: "Color";
    readonly x: "XBand";
    readonly y: "YBand";
};
export declare type ChannelTypes = typeof channelTypes;
/**
 * TEMPLATE:
 * Helper for defining encoding
 */
declare type CreateChannelDef<ChannelName extends keyof ChannelTypes, Output extends Value> = ChannelTypeToDefMap<Output>[ChannelTypes[ChannelName]];
/**
 * Encoding definition
 */
export declare type Encoding = {
    color: CreateChannelDef<'color', string>;
    x: CreateChannelDef<'x', number | null>;
    y: CreateChannelDef<'y', number | null>;
};
/**
 * TEMPLATE:
 * Can use this to get returned type of a Channel
 * example usage: ChannelOutput<'x'>
 */
export declare type ChannelOutput<ChannelName extends keyof Encoding> = ExtractChannelOutput<Encoding[ChannelName]>;
declare const Encoder_base: {
    new (spec: import("../encodeable/types/Specification").PartialSpec<Encoding, import("../encodeable/types/Specification").BaseOptions>): {
        readonly spec: import("../encodeable/types/Specification").FullSpec<Encoding, import("../encodeable/types/Specification").BaseOptions>;
        readonly channelTypes: {
            readonly color: "Color";
            readonly x: "XBand";
            readonly y: "YBand";
        };
        readonly channels: {
            readonly color: import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").MarkPropChannelDef<string>>;
            readonly x: import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").XFieldDef<number | null>>;
            readonly y: import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").YFieldDef<number | null>>;
        };
        readonly legends: {
            [key: string]: ("color" | "x" | "y")[];
        };
        createFullSpec(spec: import("../encodeable/types/Specification").PartialSpec<Encoding, import("../encodeable/types/Specification").BaseOptions>, defaultEncoding?: Encoding | undefined): import("../encodeable/types/Specification").FullSpec<Encoding, import("../encodeable/types/Specification").BaseOptions>;
        getChannelNames(): ("color" | "x" | "y")[];
        getChannelsAsArray(): (import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").MarkPropChannelDef<string>> | import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").XFieldDef<number | null>> | import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").YFieldDef<number | null>>)[];
        getGroupBys(): string[];
        getLegendInfos(data: Partial<import("../encodeable/types/Data").PlainObject<string, any>>[]): {
            field: string;
            value: string | number | boolean | Date | null | undefined;
            encodedValues: Partial<Record<"color" | "x" | "y", string | number | boolean | null | undefined>>;
        }[][];
        hasLegend(): boolean;
    };
    readonly DEFAULT_ENCODING: Encoding;
    readonly ALL_CHANNEL_OPTIONS: Partial<{
        color: import("../encodeable/types/Channel").ChannelOptions;
        x: import("../encodeable/types/Channel").ChannelOptions;
        y: import("../encodeable/types/Channel").ChannelOptions;
    }>;
};
export default class Encoder extends Encoder_base {
}
export {};
