import { Value } from 'vega-lite/build/src/channeldef';
import { ChannelTypeToDefMap } from '../encodeable/types/Channel';
import { ExtractChannelOutput } from '../encodeable/types/ChannelDef';
/**
 * Define channel types
 */
declare const channelTypes: {
    readonly fill: "Color";
    readonly group: "Text";
    readonly size: "Numeric";
    readonly stroke: "Color";
    readonly tooltip: "Text";
    readonly x: "X";
    readonly y: "Y";
};
export declare type ChannelTypes = typeof channelTypes;
/**
 * TEMPLATE:
 * Helper for defining encoding
 */
declare type CreateChannelDef<ChannelName extends keyof ChannelTypes, Output extends Value> = ChannelTypeToDefMap<Output>[ChannelTypes[ChannelName]];
/**
 * Encoding definition
 */
export declare type Encoding = {
    fill: CreateChannelDef<'fill', string>;
    group: CreateChannelDef<'group', string>[];
    size: CreateChannelDef<'size', number>;
    stroke: CreateChannelDef<'stroke', string>;
    tooltip: CreateChannelDef<'tooltip', string>[];
    x: CreateChannelDef<'x', number>;
    y: CreateChannelDef<'y', number>;
};
/**
 * TEMPLATE:
 * Can use this to get returned type of a Channel
 * example usage: ChannelOutput<'x'>
 */
export declare type ChannelOutput<ChannelName extends keyof Encoding> = ExtractChannelOutput<Encoding[ChannelName]>;
declare const Encoder_base: {
    new (spec: import("../encodeable/types/Specification").PartialSpec<Encoding, import("../encodeable/types/Specification").BaseOptions>): {
        readonly spec: import("../encodeable/types/Specification").FullSpec<Encoding, import("../encodeable/types/Specification").BaseOptions>;
        readonly channelTypes: {
            readonly fill: "Color";
            readonly group: "Text";
            readonly size: "Numeric";
            readonly stroke: "Color";
            readonly tooltip: "Text";
            readonly x: "X";
            readonly y: "Y";
        };
        readonly channels: {
            readonly fill: import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").MarkPropChannelDef<string>>;
            readonly group: import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").TextChannelDef<string>>[];
            readonly size: import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").MarkPropChannelDef<number>>;
            readonly stroke: import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").MarkPropChannelDef<string>>;
            readonly tooltip: import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").TextChannelDef<string>>[];
            readonly x: import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").XFieldDef<number>>;
            readonly y: import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").YFieldDef<number>>;
        };
        /**
         * TEMPLATE:
         * Can use this to get returned type of a Channel
         * example usage: ChannelOutput<'x'>
         */
        readonly legends: {
            [key: string]: ("group" | "size" | "fill" | "stroke" | "x" | "y" | "tooltip")[];
        };
        createFullSpec(spec: import("../encodeable/types/Specification").PartialSpec<Encoding, import("../encodeable/types/Specification").BaseOptions>, defaultEncoding?: Encoding | undefined): import("../encodeable/types/Specification").FullSpec<Encoding, import("../encodeable/types/Specification").BaseOptions>;
        getChannelNames(): ("group" | "size" | "fill" | "stroke" | "x" | "y" | "tooltip")[];
        getChannelsAsArray(): (import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").MarkPropChannelDef<string>> | import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").TextChannelDef<string>>[] | import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").MarkPropChannelDef<number>> | import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").XFieldDef<number>> | import("../encodeable/ChannelEncoder").default<import("../encodeable/types/ChannelDef").YFieldDef<number>>)[];
        getGroupBys(): string[];
        getLegendInfos(data: Partial<import("../encodeable/types/Data").PlainObject<string, any>>[]): {
            field: string;
            value: string | number | boolean | Date | null | undefined;
            encodedValues: Partial<Record<"group" | "size" | "fill" | "stroke" | "x" | "y" | "tooltip", string | number | boolean | null | undefined>>;
        }[][];
        hasLegend(): boolean;
    };
    readonly DEFAULT_ENCODING: Encoding;
    readonly ALL_CHANNEL_OPTIONS: Partial<{
        fill: import("../encodeable/types/Channel").ChannelOptions;
        group: import("../encodeable/types/Channel").ChannelOptions;
        size: import("../encodeable/types/Channel").ChannelOptions;
        stroke: import("../encodeable/types/Channel").ChannelOptions;
        tooltip: import("../encodeable/types/Channel").ChannelOptions;
        x: import("../encodeable/types/Channel").ChannelOptions;
        y: import("../encodeable/types/Channel").ChannelOptions;
    }>;
};
export default class Encoder extends Encoder_base {
}
export {};
