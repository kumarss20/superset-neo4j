"use strict";/* [LICENSE TBD] */ /* eslint-disable */module.exports=function(a){// getter/setter with event firing
function b(a,b){return a.filter(function(a){return-1===b.indexOf(a)})}/** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */function c(){return"bottom"==A.nullValueSeparator?[j()+1-A.nullValueSeparatorPadding.bottom-A.nullValueSeparatorPadding.top,1]:"top"==A.nullValueSeparator?[j()+1,1+A.nullValueSeparatorPadding.bottom+A.nullValueSeparatorPadding.top]:[j()+1,1]}function d(){if(A.brushed&&A.brushed.length!==A.data.length)return!0;var a=M.currentMode().brushState();for(var b in a)if(a.hasOwnProperty(b))return!0;return!1}function e(a){var b=d3.map(),c=d3.map();return A.data.forEach(function(b){var d=D[a](b[a]);c.has(d)||c.set(d,0);var e=c.get(d);c.set(d,e+1)}),A.data.forEach(function(d){A.dimensions.map(function(e){var f=D[a](d[a]);if(!b.has(f)){var g=d3.map();b.set(f,g)}b.get(f).has(e)||b.get(f).set(e,0);var h=b.get(f).get(e);h+=D[e](d[e])/c.get(f),b.get(f).set(e,h)})}),b}function f(b){// center between axes
for(var c=[],d=A.dimensions,e=d.length,f=.5,a=0;a<e;++a){// centroids on 'real' axes
var g=z(d[a]),h=D[d[a]](b[d[a]]);// centroids on 'virtual' axes
if(c.push($V([g,h])),a<e-1){var j=g+f*(z(d[a+1])-g),k=h+f*(D[d[a+1]](b[d[a+1]])-h);if(null!==A.bundleDimension){var l=A.clusterCentroids.get(D[A.bundleDimension](b[A.bundleDimension])).get(d[a]),m=A.clusterCentroids.get(D[A.bundleDimension](b[A.bundleDimension])).get(d[a+1]),n=.5*(l+m);k=n+(1-A.bundlingStrength)*(k-n)}c.push($V([j,k]))}}return c}function k(b){var c=b.length,d=A.smoothness,a=[];a.push(b[0]),a.push($V([b[0].e(1)+2*d*(b[1].e(1)-b[0].e(1)),b[0].e(2)]));for(var e=1;e<c-1;++e){var f=b[e],g=b[e-1],h=b[e+1],i=g.subtract(h);a.push(f.add(i.x(d))),a.push(f),a.push(f.subtract(i.x(d)))}return a.push($V([b[c-1].e(1)+2*d*(b[c-2].e(1)-b[c-1].e(1)),b[c-1].e(2)])),a.push(b[c-1]),a}// draw single cubic bezier curve
function l(a,b){var c=f(a),d=k(c);b.moveTo(d[0].e(1),d[0].e(2));for(var e=1;e<d.length;e+=3){if(A.showControlPoints)for(var g=0;3>g;g++)b.fillRect(d[e+g].e(1),d[e+g].e(2),2,2);b.bezierCurveTo(d[e].e(1),d[e].e(2),d[e+1].e(1),d[e+1].e(2),d[e+2].e(1),d[e+2].e(2))}}// draw single polyline
function m(a,b){b.beginPath(),null!==A.bundleDimension&&0<A.bundlingStrength||0<A.smoothness?l(a,b):o(a,b),b.stroke()}// draw many polylines of the same color
// returns the y-position just beyond the separating null value line
function n(){return"bottom"==A.nullValueSeparator?j()+1:"top"==A.nullValueSeparator?1:(console.log("A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'."),j()+1)}function o(a,b){A.dimensions.map(function(c,d){0==d?b.moveTo(z(c),"undefined"==typeof a[c]?n():D[c](a[c])):b.lineTo(z(c),"undefined"==typeof a[c]?n():D[c](a[c]))})}function p(a,b){return H.brushed.strokeStyle=null===A.brushedColor?d3.functor(A.color)(a,b):d3.functor(A.brushedColor)(a,b),m(a,H.brushed)}function q(a,b){return H.foreground.strokeStyle=d3.functor(A.color)(a,b),m(a,H.foreground)}function r(a,b){return H.highlight.strokeStyle=d3.functor(A.color)(a,b),m(a,H.highlight)}function s(a){y.svg.selectAll(".dimension");y.flip(a),d3.select(this.parentElement).transition().duration(1100).call(G.scale(D[a])),y.render()}function t(){var a=d3.event.deltaY;a=0>a?-5:a,a=0<a?5:a,A.dimensionTitleRotation+=a,y.svg.selectAll("text.label").attr("transform","translate(0,-5) rotate("+A.dimensionTitleRotation+")"),d3.event.preventDefault()}function u(a){return a in A.dimensionTitles?A.dimensionTitles[a]:a;// dimension display names
}// This function can be used for 'live' updates of brushes. That is, during the
// specification of a brush, this method can be called to update the view.
//
// @param newSelection - The new set of data items that is currently contained
//                       by the brushes
function v(a){A.brushed=a,B.brush.call(y,A.brushed),y.renderBrushed()}function x(a){if(!arguments.length)return M.predicate;if(a=(a+"").toUpperCase(),"AND"!==a&&"OR"!==a)throw"Invalid predicate "+a;return M.predicate=a,A.brushed=M.currentMode().selected(),y.renderBrushed(),y}function z(a){var b=E[a];return null==b?w(a):b}var A={data:[],highlighted:[],dimensions:[],dimensionTitles:{},dimensionTitleRotation:0,types:{},brushed:!1,brushedColor:null,alphaOnBrushed:0,mode:"default",rate:20,width:600,height:300,margin:{top:24,right:0,bottom:12,left:0},nullValueSeparator:"undefined",// set to "top" or "bottom"
nullValueSeparatorPadding:{top:8,right:0,bottom:8,left:0},color:"#069",composite:"source-over",alpha:.7,bundlingStrength:.5,bundleDimension:null,smoothness:0,showControlPoints:!1,hideAxis:[]};(function(a,b){for(var c in b)a[c]=b[c];return a})(A,a);var i,y=function(a){return a=y.selection=d3.select(a),A.width=a[0][0].clientWidth,A.height=a[0][0].clientHeight,["marks","foreground","brushed","highlight"].forEach(function(b){I[b]=a.append("canvas").attr("class",b)[0][0],H[b]=I[b].getContext("2d")}),y.svg=a.append("svg").attr("width",A.width).attr("height",A.height).append("svg:g").attr("transform","translate("+A.margin.left+","+A.margin.top+")"),y},B=d3.dispatch.apply(this,["render","resize","highlight","brush","brushend","axesreorder"].concat(d3.keys(A))),C=function(){return A.width-A.margin.right-A.margin.left},j=function(){return A.height-A.margin.top-A.margin.bottom},h={brushable:!1,reorderable:!1,axes:!1,interactive:!1,debug:!1},w=d3.scale.ordinal(),D={},E={},F=d3.svg.line(),G=d3.svg.axis().orient("left").ticks(5),// groups for axes, brushes
H={},I={},J=d3.dispatch.apply(this,d3.keys(A)).on("composite",function(a){H.foreground.globalCompositeOperation=a.value,H.brushed.globalCompositeOperation=a.value}).on("alpha",function(a){H.foreground.globalAlpha=a.value,H.brushed.globalAlpha=a.value}).on("brushedColor",function(a){H.brushed.strokeStyle=a.value}).on("width",function(){y.resize()}).on("height",function(){y.resize()}).on("margin",function(){y.resize()}).on("rate",function(a){L.rate(a.value),K.rate(a.value)}).on("dimensions",function(){w.domain(A.dimensions),h.interactive&&y.render().updateAxes()}).on("bundleDimension",function(a){A.dimensions.length||y.detectDimensions(),A.dimensions[0]in D||y.autoscale(),"number"==typeof a.value?a.value<A.dimensions.length?A.bundleDimension=A.dimensions[a.value]:a.value<A.hideAxis.length&&(A.bundleDimension=A.hideAxis[a.value]):A.bundleDimension=a.value,A.clusterCentroids=e(A.bundleDimension)}).on("hideAxis",function(a){A.dimensions.length||y.detectDimensions(),y.dimensions(b(A.dimensions,a.value))});y.state=A,y.flags=h,function(a,b,c){d3.keys(b).forEach(function(d){a[d]=function(e){if(!arguments.length)return b[d];var f=b[d];return b[d]=e,J[d].call(y,{value:e,previous:f}),c[d].call(y,{value:e,previous:f}),a}})}(y,A,B),d3.rebind(y,B,"on"),y.autoscale=function(){// yscale
var a={date:function date(a){var b=d3.extent(A.data,function(b){return b[a]?b[a].getTime():null});// special case if single value
return b[0]===b[1]?d3.scale.ordinal().domain([b[0]]).rangePoints(c()):d3.time.scale().domain(b).range(c())},number:function number(a){var b=d3.extent(A.data,function(b){return+b[a]});// special case if single value
return b[0]===b[1]?d3.scale.ordinal().domain([b[0]]).rangePoints(c()):d3.scale.linear().domain(b).range(c())},string:function string(a){var d={},e=[];// Let's get the count for each value so that we can sort the domain based
// on the number of items for each value.
return A.data.map(function(b){void 0===b[a]&&"undefined"!==A.nullValueSeparator||(void 0===d[b[a]]?d[b[a]]=1:d[b[a]]=d[b[a]]+1)}),e=Object.getOwnPropertyNames(d).sort(function(c,a){return d[c]-d[a]}),d3.scale.ordinal().domain(e).rangePoints(c())}};return A.dimensions.forEach(function(b){D[b]=a[A.types[b]](b)}),A.hideAxis.forEach(function(b){D[b]=a[A.types[b]](b)}),w.rangePoints([0,C()],1),y.selection.selectAll("canvas").style("margin-top",A.margin.top+"px").style("margin-left",A.margin.left+"px").attr("width",C()+2).attr("height",j()+2),H.foreground.strokeStyle=A.color,H.foreground.lineWidth=1.4,H.foreground.globalCompositeOperation=A.composite,H.foreground.globalAlpha=A.alpha,H.brushed.strokeStyle=A.brushedColor,H.brushed.lineWidth=1.4,H.brushed.globalCompositeOperation=A.composite,H.brushed.globalAlpha=A.alpha,H.highlight.lineWidth=3,this},y.scale=function(a,b){return D[a].domain(b),this},y.flip=function(a){// works
return D[a].domain(D[a].domain().reverse()),this},y.commonScale=function(a,b){"undefined"==typeof a&&(a=!0);// scales of the same type
var c=A.dimensions.concat(A.hideAxis).filter(function(a){return A.types[a]==(b||"number")});if(a){var e=d3.extent(c.map(function(a){return D[a].domain()}).reduce(function(c,a){return c.concat(a)}));c.forEach(function(a){D[a].domain(e)})}else c.forEach(function(a){D[a].domain(d3.extent(A.data,function(b){return+b[a]}))});// update centroids
return null!==A.bundleDimension&&y.bundleDimension(A.bundleDimension),this},y.detectDimensions=function(){return y.types(y.detectDimensionTypes(A.data)),y.dimensions(d3.keys(y.types())),this},y.toType=function(a){return{}.toString.call(a).match(/\s([a-zA-Z]+)/)[1].toLowerCase()},y.toTypeCoerceNumbers=function(a){return parseFloat(a)==a&&null!=a?"number":y.toType(a)},y.detectDimensionTypes=function(a){var b={};return d3.keys(a[0]).forEach(function(c){b[c]=y.toTypeCoerceNumbers(a[0][c])}),b},y.render=function(){return A.dimensions.length||y.detectDimensions(),A.dimensions[0]in D||y.autoscale(),y.render[A.mode](),B.render.call(this),this},y.renderBrushed=function(){return A.dimensions.length||y.detectDimensions(),A.dimensions[0]in D||y.autoscale(),y.renderBrushed[A.mode](),B.render.call(this),this},y.render.default=function(){y.clear("foreground"),y.clear("highlight"),y.renderBrushed.default(),A.data.forEach(q)};var K=d3.renderQueue(q).rate(50).clear(function(){y.clear("foreground"),y.clear("highlight")});y.render.queue=function(){y.renderBrushed.queue(),K(A.data)},y.renderBrushed.default=function(){y.clear("brushed"),d()&&A.brushed.forEach(p)};var L=d3.renderQueue(p).rate(50).clear(function(){y.clear("brushed")});y.renderBrushed.queue=function(){d()?L(A.brushed):L([])},y.shadows=function(){return h.shadows=!0,y.alphaOnBrushed(.1),y.render(),this},y.axisDots=function(a){var a=a||.1,b=y.ctx.marks,c=2*Math.PI;return b.globalAlpha=d3.min([1/Math.pow(A.data.length,1/2),1]),A.data.forEach(function(e){A.dimensions.map(function(d){b.beginPath(),b.arc(z(d),D[d](e[d]),a,0,c),b.stroke(),b.fill()})}),this},y.clear=function(a){return H[a].clearRect(0,0,C()+2,j()+2),"brushed"===a&&d()&&(H.brushed.fillStyle=y.selection.style("background-color"),H.brushed.globalAlpha=1-A.alphaOnBrushed,H.brushed.fillRect(0,0,C()+2,j()+2),H.brushed.globalAlpha=A.alpha),this},d3.rebind(y,G,"ticks","orient","tickValues","tickSubdivide","tickSize","tickPadding","tickFormat"),y.createAxes=function(){return i&&y.removeAxes(),i=y.svg.selectAll(".dimension").data(A.dimensions,function(a){return a}).enter().append("svg:g").attr("class","dimension").attr("transform",function(a){return"translate("+w(a)+")"}),i.append("svg:g").attr("class","axis").attr("transform","translate(0,0)").each(function(a){d3.select(this).call(G.scale(D[a]))}).append("svg:text").attr({"text-anchor":"middle",y:0,transform:"translate(0,-5) rotate("+A.dimensionTitleRotation+")",x:0,class:"label"}).text(u).on("dblclick",s).on("wheel",t),"top"==A.nullValueSeparator?y.svg.append("line").attr("x1",0).attr("y1",1+A.nullValueSeparatorPadding.top).attr("x2",C()).attr("y2",1+A.nullValueSeparatorPadding.top).attr("stroke-width",1).attr("stroke","#777").attr("fill","none").attr("shape-rendering","crispEdges"):"bottom"==A.nullValueSeparator&&y.svg.append("line").attr("x1",0).attr("y1",j()+1-A.nullValueSeparatorPadding.bottom).attr("x2",C()).attr("y2",j()+1-A.nullValueSeparatorPadding.bottom).attr("stroke-width",1).attr("stroke","#777").attr("fill","none").attr("shape-rendering","crispEdges"),h.axes=!0,this},y.removeAxes=function(){return i.remove(),this},y.updateAxes=function(){var a=y.svg.selectAll(".dimension").data(A.dimensions);// Enter
if(a.enter().append("svg:g").attr("class","dimension").attr("transform",function(a){return"translate("+z(a)+")"}).style("opacity",0).append("svg:g").attr("class","axis").attr("transform","translate(0,0)").each(function(a){d3.select(this).call(G.scale(D[a]))}).append("svg:text").attr({"text-anchor":"middle",y:0,transform:"translate(0,-5) rotate("+A.dimensionTitleRotation+")",x:0,class:"label"}).text(u).on("dblclick",s).on("wheel",t),a.attr("opacity",0),a.select(".axis").transition().duration(1100).each(function(a){d3.select(this).call(G.scale(D[a]))}),a.select(".label").transition().duration(1100).text(u).attr("transform","translate(0,-5) rotate("+A.dimensionTitleRotation+")"),a.exit().remove(),i=y.svg.selectAll(".dimension"),i.transition().duration(1100).attr("transform",function(a){return"translate("+z(a)+")"}).style("opacity",1),y.svg.selectAll(".axis").transition().duration(1100).each(function(a){d3.select(this).call(G.scale(D[a]))}),h.brushable&&y.brushable(),h.reorderable&&y.reorderable(),"None"!==y.brushMode()){var b=y.brushMode();y.brushMode("None"),y.brushMode(b)}return this},y.reorderable=function(){return i||y.createAxes(),i.style("cursor","move").call(d3.behavior.drag().on("dragstart",function(a){E[a]=this.__origin__=w(a)}).on("drag",function(a){E[a]=Math.min(C(),Math.max(0,this.__origin__+=d3.event.dx)),A.dimensions.sort(function(c,a){return z(c)-z(a)}),w.domain(A.dimensions),y.render(),i.attr("transform",function(a){return"translate("+z(a)+")"})}).on("dragend",function(a){// Let's see if the order has changed and send out an event if so.
for(var b=0,c=A.dimensions.indexOf(a),d=this,e=this.parentElement;null!=(d=d.previousElementSibling);)++b;b!==c&&(B.axesreorder.call(y,A.dimensions),b>c?e.insertBefore(this,e.children[c-1]):c+1<e.children.length?e.insertBefore(this,e.children[c+1]):e.appendChild(this)),delete this.__origin__,delete E[a],d3.select(this).transition().attr("transform","translate("+w(a)+")"),y.render()})),h.reorderable=!0,this},y.reorder=function(c){var d=A.dimensions.slice(0);A.dimensions.sort(function(d,a){var b=D[d](c[d])-D[a](c[a]);// Array.sort is not necessarily stable, this means that if pixelDifference is zero
// the ordering of dimensions might change unexpectedly. This is solved by sorting on
// variable name in that case.
return 0==b?d.localeCompare(a):b;// else
});// NOTE: this is relatively cheap given that:
// number of dimensions < number of data items
// Thus we check equality of order to prevent rerendering when this is the case.
var e=!1;if(d.some(function(a,b){return e=a!==A.dimensions[b],e}),e){w.domain(A.dimensions);var f=A.highlighted.slice(0);y.unhighlight(),i.transition().duration(1500).attr("transform",function(a){return"translate("+w(a)+")"}),y.render(),0!==f.length&&y.highlight(f)}},y.adjacent_pairs=function(a){for(var b=[],c=0;c<a.length-1;c++)b.push([a[c],a[c+1]]);return b};var M={modes:{None:{install:function install(){},// Nothing to be done.
uninstall:function uninstall(){},// Nothing to be done.
selected:function selected(){return[]},// Nothing to return
brushState:function brushState(){return{}}}},mode:"None",predicate:"AND",currentMode:function currentMode(){return this.modes[this.mode]}};return y.brushModes=function(){return Object.getOwnPropertyNames(M.modes)},y.brushMode=function(a){if(0===arguments.length)return M.mode;if(-1===y.brushModes().indexOf(a))throw"pc.brushmode: Unsupported brush mode: "+a;// Make sure that we don't trigger unnecessary events by checking if the mode
// actually changes.
return a!==M.mode&&("None"!==M.mode&&y.brushReset(),M.modes[M.mode].uninstall(y),M.mode=a,M.modes[M.mode].install(),"None"===a?delete y.brushPredicate:y.brushPredicate=x),y},function(){function a(a){return!h[a].empty()}// data within extents
function b(){var b=A.dimensions.filter(a),c=b.map(function(a){return h[a].extent()});// We don't want to return the full data set when there are no axes brushed.
// Actually, when there are no axes brushed, by definition, no items are
// selected. So, let's avoid the filtering and just return false.
//if (actives.length === 0) return false;
// Resolves broken examples for now. They expect to get the full dataset back from empty brushes
if(0===b.length)return A.data;// test if within range
var e={date:function date(a,b,d){return"function"==typeof D[b].rangePoints?c[d][0]<=D[b](a[b])&&D[b](a[b])<=c[d][1]:c[d][0]<=a[b]&&a[b]<=c[d][1]},number:function number(a,b,d){return"function"==typeof D[b].rangePoints?c[d][0]<=D[b](a[b])&&D[b](a[b])<=c[d][1]:c[d][0]<=a[b]&&a[b]<=c[d][1]},string:function string(a,b,d){return c[d][0]<=D[b](a[b])&&D[b](a[b])<=c[d][1]}};return A.data.filter(function(a){switch(M.predicate){case"AND":return b.every(function(b,c){return e[A.types[b]](a,b,c)});case"OR":return b.some(function(b,c){return e[A.types[b]](a,b,c)});default:throw"Unknown brush predicate "+A.brushPredicate;}})}function c(a){if("undefined"==typeof a){var a={};return A.dimensions.forEach(function(b){var c=h[b];if(void 0!==c&&!c.empty()){var d=c.extent();d.sort(d3.ascending),a[b]=d}}),a}//first get all the brush selections
var b={};i.selectAll(".brush").each(function(a){b[a]=d3.select(this)}),A.dimensions.forEach(function(c){if(void 0!==a[c]){var d=h[c];void 0!==d&&(d.extent(a[c]),d(b[c]),d.event(b[c]))}}),y.renderBrushed()}function e(a){var c=d3.svg.brush();return c.y(D[a]).on("brushstart",function(){null!==d3.event.sourceEvent&&d3.event.sourceEvent.stopPropagation()}).on("brush",function(){v(b())}).on("brushend",function(){B.brushend.call(y,A.brushed)}),h[a]=c,c}function f(){return A.brushed=!1,i&&(i.selectAll(".brush").each(function(a){d3.select(this).call(h[a].clear())}),y.renderBrushed()),this}function g(){return i||y.createAxes(),i.append("svg:g").attr("class","brush").each(function(a){d3.select(this).call(e(a))}).selectAll("rect").style("visibility",null).attr("x",-15).attr("width",30),y.brushExtents=c,y.brushReset=f,y}var h={};M.modes["1D-axes"]={install:g,uninstall:function uninstall(){i.selectAll(".brush").remove(),h={},delete y.brushExtents,delete y.brushReset},selected:b,brushState:c}}(),function(){function a(b,c){var d=y.selection.select("svg").select("g#strums"),e=b.dims.i,f=[b.p1,b.p2],g=d.selectAll("line#strum-"+e).data([b]),i=d.selectAll("circle#strum-"+e).data(f),j=d3.behavior.drag();g.enter().append("line").attr("id","strum-"+e).attr("class","strum"),g.attr("x1",function(a){return a.p1[0]}).attr("y1",function(a){return a.p1[1]}).attr("x2",function(a){return a.p2[0]}).attr("y2",function(a){return a.p2[1]}).attr("stroke","black").attr("stroke-width",2),j.on("drag",function(c,d){var e=d3.event;++d,b["p"+d][0]=Math.min(Math.max(b.minX+1,e.x),b.maxX),b["p"+d][1]=Math.min(Math.max(b.minY,e.y),b.maxY),a(b,d-1)}).on("dragend",h()),i.enter().append("circle").attr("id","strum-"+e).attr("class","strum"),i.attr("cx",function(a){return a[0]}).attr("cy",function(a){return a[1]}).attr("r",5).style("opacity",function(a,b){return void 0!==c&&b===c?.8:0}).on("mouseover",function(){d3.select(this).style("opacity",.8)}).on("mouseout",function(){d3.select(this).style("opacity",0)}).call(j)}function b(a){var b={i:-1,left:void 0,right:void 0};return A.dimensions.some(function(c,d){if(w(c)<a[0]){var e=A.dimensions[d+1];return b.i=d,b.left=c,b.right=e,!1}return!0}),void 0===b.left?(b.i=0,b.left=A.dimensions[0],b.right=A.dimensions[1]):void 0===b.right&&(b.i=A.dimensions.length-1,b.right=b.left,b.left=A.dimensions[A.dimensions.length-2]),b}function c(){// First we need to determine between which two axes the sturm was started.
// This will determine the freedom of movement, because a strum can
// logically only happen between two axes, so no movement outside these axes
// should be allowed.
return function(){var a,c,d=d3.mouse(k[0][0]);d[0]-=A.margin.left,d[1]-=A.margin.top,a=b(d),c={p1:d,dims:a,minX:w(a.left),maxX:w(a.right),minY:0,maxY:j()},l[a.i]=c,l.active=a.i,c.p1[0]=Math.min(Math.max(c.minX,d[0]),c.maxX),c.p2=c.p1.slice()}}function d(){return function(){var b=d3.event,c=l[l.active];// Make sure that the point is within the bounds
c.p2[0]=Math.min(Math.max(c.minX+1,b.x-A.margin.left),c.maxX),c.p2[1]=Math.min(Math.max(c.minY,b.y-A.margin.top),c.maxY),a(c,1)}}function e(a,b){var c=[a.p1[0]-a.minX,a.p1[1]-a.minX],d=[a.p2[0]-a.minX,a.p2[1]-a.minX],e=1-b/c[0],f=c[1]*(1-e),g=1-b/d[0],h=d[1]*(1-g);// test if point falls between lines
return function(a){var b=a[0],c=a[1],d=e*b+f,i=g*b+h;return!!(c>Math.min(d,i)&&c<Math.max(d,i))}}function f(){function a(a,b){var c=l[b],d=e(c,l.width(b)),f=c.dims.left,g=c.dims.right,h=D[f],i=D[g],j=[h(a[f])-c.minX,i(a[g])-c.minX];return d(j)}var b=Object.getOwnPropertyNames(l),c=A.data;// Get the ids of the currently active strums.
return b=b.filter(function(a){return!isNaN(a)}),0===b.length?c:c.filter(function(c){switch(M.predicate){case"AND":return b.every(function(b){return a(c,b)});case"OR":return b.some(function(b){return a(c,b)});default:throw"Unknown brush predicate "+A.brushPredicate;}})}function g(){var a=l[l.active],b=y.selection.select("svg").select("g#strums");delete l[l.active],l.active=void 0,b.selectAll("line#strum-"+a.dims.i).remove(),b.selectAll("circle#strum-"+a.dims.i).remove()}function h(){return function(){var a=A.data,b=l[l.active];// Okay, somewhat unexpected, but not totally unsurprising, a mousclick is
// considered a drag without move. So we have to deal with that case
b&&b.p1[0]===b.p2[0]&&b.p1[1]===b.p2[1]&&g(l),a=f(l),l.active=void 0,A.brushed=a,y.renderBrushed(),B.brushend.call(y,A.brushed)}}function i(a){return function(){var b=Object.getOwnPropertyNames(a).filter(function(a){return!isNaN(a)});b.forEach(function(b){a.active=b,g(a)}),h(a)()}}var k,l={};M.modes["2D-strums"]={install:function(){var a=d3.behavior.drag();// Map of current strums. Strums are stored per segment of the PC. A segment,
// being the area between two axes. The left most area is indexed at 0.
l.active=void 0,l.width=function(a){var b=l[a];return void 0===b?void 0:b.maxX-b.minX},y.on("axesreorder.strums",function(){// Checks if the first dimension is directly left of the second dimension.
function a(a,b){var c=A.dimensions.length;return A.dimensions.some(function(e,d){return e===a&&d+d<c&&A.dimensions[d+1]===b})}var b=Object.getOwnPropertyNames(l).filter(function(a){return!isNaN(a)});0<b.length&&(b.forEach(function(b){var c=l[b].dims;l.active=b,a(c.left,c.right)||g(l)}),h(l)())}),y.selection.select("svg").append("g").attr("id","strums").attr("transform","translate("+A.margin.left+","+A.margin.top+")"),y.brushReset=i(l),a.on("dragstart",c(l)).on("drag",d(l)).on("dragend",h(l)),k=y.selection.select("svg").insert("rect","g#strums").attr("id","strum-events").attr("x",A.margin.left).attr("y",A.margin.top).attr("width",C()).attr("height",j()+2).style("opacity",0).call(a)},uninstall:function uninstall(){y.selection.select("svg").select("g#strums").remove(),y.selection.select("svg").select("rect#strum-events").remove(),y.on("axesreorder.strums",void 0),delete y.brushReset,k=void 0},selected:f,brushState:function brushState(){return l}}}(),function(){function a(a){return!h[a].empty()}// data within extents
function b(){var b=A.dimensions.filter(a),c=b.map(function(a){return h[a].extent()});// We don't want to return the full data set when there are no axes brushed.
// Actually, when there are no axes brushed, by definition, no items are
// selected. So, let's avoid the filtering and just return false.
//if (actives.length === 0) return false;
// Resolves broken examples for now. They expect to get the full dataset back from empty brushes
if(0===b.length)return A.data;// test if within range
var e={date:function date(a,c,d,e){return"function"==typeof D[c].rangePoints?e[0]<=D[c](a[c])&&D[c](a[c])<=e[1]:e[0]<=a[c]&&a[c]<=e[1]},number:function number(a,c,d,e){return"function"==typeof D[c].rangePoints?e[0]<=D[c](a[c])&&D[c](a[c])<=e[1]:e[0]<=a[c]&&a[c]<=e[1]},string:function string(a,c,d,e){return e[0]<=D[c](a[c])&&D[c](a[c])<=e[1]}};return A.data.filter(function(a){switch(M.predicate){case"AND":return b.every(function(d,f){return c[f].some(function(c){return e[A.types[d]](a,d,f,c)})});case"OR":return b.some(function(d,f){return c[f].some(function(c){return e[A.types[d]](a,d,f,c)})});default:throw"Unknown brush predicate "+A.brushPredicate;}})}function c(){var a={};return A.dimensions.forEach(function(b){var c=h[b];if(void 0!==c&&!c.empty()){var d=c.extent();a[b]=d}}),a}function e(a){var c=d3.svg.multibrush();return c.y(D[a]).on("brushstart",function(){null!==d3.event.sourceEvent&&d3.event.sourceEvent.stopPropagation()}).on("brush",function(){v(b())}).on("brushend",function(){v(b()),B.brushend.call(y,A.brushed)}).extentAdaption(function(a){a.style("visibility",null).attr("x",-15).attr("width",30)}).resizeAdaption(function(a){a.selectAll("rect").attr("x",-15).attr("width",30)}),h[a]=c,c}function f(){return A.brushed=!1,i&&(i.selectAll(".brush").each(function(a){d3.select(this).call(h[a].clear())}),y.renderBrushed()),this}function g(){return i||y.createAxes(),i.append("svg:g").attr("class","brush").each(function(a){d3.select(this).call(e(a))}).selectAll("rect").style("visibility",null).attr("x",-15).attr("width",30),y.brushExtents=c,y.brushReset=f,y}if("function"==typeof d3.svg.multibrush){var h={};M.modes["1D-axes-multi"]={install:g,uninstall:function uninstall(){i.selectAll(".brush").remove(),h={},delete y.brushExtents,delete y.brushReset},selected:b,brushState:c}}}(),function(){function a(b,c){var d=y.selection.select("svg").select("g#arcs"),e=b.dims.i,f=[b.p2,b.p3],g=d.selectAll("line#arc-"+e).data([{p1:b.p1,p2:b.p2},{p1:b.p1,p2:b.p3}]),h=d.selectAll("circle#arc-"+e).data(f),j=d3.behavior.drag(),k=d.selectAll("path#arc-"+e).data([b]);k.enter().append("path").attr("id","arc-"+e).attr("class","arc").style("fill","orange").style("opacity",.5),k.attr("d",b.arc).attr("transform","translate("+b.p1[0]+","+b.p1[1]+")"),g.enter().append("line").attr("id","arc-"+e).attr("class","arc"),g.attr("x1",function(a){return a.p1[0]}).attr("y1",function(a){return a.p1[1]}).attr("x2",function(a){return a.p2[0]}).attr("y2",function(a){return a.p2[1]}).attr("stroke","black").attr("stroke-width",2),j.on("drag",function(c,d){var f=d3.event,g=0;d+=2,b["p"+d][0]=Math.min(Math.max(b.minX+1,f.x),b.maxX),b["p"+d][1]=Math.min(Math.max(b.minY,f.y),b.maxY),g=3===d?m.startAngle(e):m.endAngle(e),(b.startAngle<Math.PI&&b.endAngle<Math.PI&&g<Math.PI||b.startAngle>=Math.PI&&b.endAngle>=Math.PI&&g>=Math.PI)&&(2===d?(b.endAngle=g,b.arc.endAngle(g)):3==d&&(b.startAngle=g,b.arc.startAngle(g))),a(b,d-2)}).on("dragend",i()),h.enter().append("circle").attr("id","arc-"+e).attr("class","arc"),h.attr("cx",function(a){return a[0]}).attr("cy",function(a){return a[1]}).attr("r",5).style("opacity",function(a,b){return void 0!==c&&b===c?.8:0}).on("mouseover",function(){d3.select(this).style("opacity",.8)}).on("mouseout",function(){d3.select(this).style("opacity",0)}).call(j)}function b(a){var b={i:-1,left:void 0,right:void 0};return A.dimensions.some(function(c,d){if(w(c)<a[0]){var e=A.dimensions[d+1];return b.i=d,b.left=c,b.right=e,!1}return!0}),void 0===b.left?(b.i=0,b.left=A.dimensions[0],b.right=A.dimensions[1]):void 0===b.right&&(b.i=A.dimensions.length-1,b.right=b.left,b.left=A.dimensions[A.dimensions.length-2]),b}function c(){// First we need to determine between which two axes the arc was started.
// This will determine the freedom of movement, because a arc can
// logically only happen between two axes, so no movement outside these axes
// should be allowed.
return function(){var a,c,d=d3.mouse(l[0][0]);d[0]-=A.margin.left,d[1]-=A.margin.top,a=b(d),c={p1:d,dims:a,minX:w(a.left),maxX:w(a.right),minY:0,maxY:j(),startAngle:void 0,endAngle:void 0,arc:d3.svg.arc().innerRadius(0)},m[a.i]=c,m.active=a.i,c.p1[0]=Math.min(Math.max(c.minX,d[0]),c.maxX),c.p2=c.p1.slice(),c.p3=c.p1.slice()}}function d(){return function(){var b=d3.event,c=m[m.active];// Make sure that the point is within the bounds
c.p2[0]=Math.min(Math.max(c.minX+1,b.x-A.margin.left),c.maxX),c.p2[1]=Math.min(Math.max(c.minY,b.y-A.margin.top),c.maxY),c.p3=c.p2.slice(),a(c,1)}}// some helper functions
function e(c,a){return Math.sqrt(c*c+a*a)}/**
     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.
     * However, one can only select lines from 0 to PI, so we compute the
     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2
     * are 12 and 6 o'clock respectively.
     */function f(a){var b=p(a.startAngle),c=p(a.endAngle);if(b>c){var d=b;b=c,c=d}// test if segment angle is contained in angle interval
return function(d){return!!(d>=b&&d<=c)}}function g(){function a(g,d){var h=m[d],i=f(h),j=h.dims.left,k=h.dims.right,l=D[j],n=D[k],o=m.width(d),a=l(g[j])-n(g[k]),b=e(o,a),c=Math.asin(a/b);// rad in [-PI/2, PI/2]
return i(c)}var b=Object.getOwnPropertyNames(m),c=A.data;// Get the ids of the currently active arcs.
return b=b.filter(function(a){return!isNaN(a)}),0===b.length?c:c.filter(function(c){switch(M.predicate){case"AND":return b.every(function(b){return a(c,b)});case"OR":return b.some(function(b){return a(c,b)});default:throw"Unknown brush predicate "+A.brushPredicate;}})}function h(){var a=m[m.active],b=y.selection.select("svg").select("g#arcs");delete m[m.active],m.active=void 0,b.selectAll("line#arc-"+a.dims.i).remove(),b.selectAll("circle#arc-"+a.dims.i).remove(),b.selectAll("path#arc-"+a.dims.i).remove()}function i(){return function(){var a=A.data,b=m[m.active];// Okay, somewhat unexpected, but not totally unsurprising, a mousclick is
// considered a drag without move. So we have to deal with that case
if(b&&b.p1[0]===b.p2[0]&&b.p1[1]===b.p2[1]&&h(m),b){var c=m.startAngle(m.active);b.startAngle=c,b.endAngle=c,b.arc.outerRadius(m.length(m.active)).startAngle(c).endAngle(c)}a=g(m),m.active=void 0,A.brushed=a,y.renderBrushed(),B.brushend.call(y,A.brushed)}}function k(a){return function(){var b=Object.getOwnPropertyNames(a).filter(function(a){return!isNaN(a)});b.forEach(function(b){a.active=b,h(a)}),i(a)()}}var l,m={},n=function(){var a=Math.PI/180;return function(b){return b*a}}(),o=function(){var a=180/Math.PI;return function(b){return b*a}}(),p=function(a){var b=a;return a>Math.PI?(b=a-1.5*Math.PI,b=a-1.5*Math.PI):(b=a-.5*Math.PI,b=a-.5*Math.PI),-b};M.modes.angular={install:function(){var a=d3.behavior.drag();// Map of current arcs. arcs are stored per segment of the PC. A segment,
// being the area between two axes. The left most area is indexed at 0.
m.active=void 0,m.width=function(a){var b=m[a];return void 0===b?void 0:b.maxX-b.minX},angle=function angle(d,f){var g=d[0]-f[0],a=d[1]-f[1],b=e(g,a);return Math.asin(a/b)},m.endAngle=function(a){var b=m[a];if(void 0===b)return void 0;var c=angle(b.p1,b.p2),d=-c+Math.PI/2;return b.p1[0]>b.p2[0]&&(d=2*Math.PI-d),d},m.startAngle=function(a){var b=m[a];if(void 0===b)return void 0;var c=angle(b.p1,b.p3),d=-c+Math.PI/2;return b.p1[0]>b.p3[0]&&(d=2*Math.PI-d),d},m.length=function(d){var f=m[d];if(void 0===f)return void 0;var g=f.p1[0]-f.p2[0],a=f.p1[1]-f.p2[1],b=e(g,a);return b},y.on("axesreorder.arcs",function(){// Checks if the first dimension is directly left of the second dimension.
function a(a,b){var c=A.dimensions.length;return A.dimensions.some(function(e,d){return e===a&&d+d<c&&A.dimensions[d+1]===b})}var b=Object.getOwnPropertyNames(m).filter(function(a){return!isNaN(a)});0<b.length&&(b.forEach(function(b){var c=m[b].dims;m.active=b,a(c.left,c.right)||h(m)}),i(m)())}),y.selection.select("svg").append("g").attr("id","arcs").attr("transform","translate("+A.margin.left+","+A.margin.top+")"),y.brushReset=k(m),a.on("dragstart",c(m)).on("drag",d(m)).on("dragend",i(m)),l=y.selection.select("svg").insert("rect","g#arcs").attr("id","arc-events").attr("x",A.margin.left).attr("y",A.margin.top).attr("width",C()).attr("height",j()+2).style("opacity",0).call(a)},uninstall:function uninstall(){y.selection.select("svg").select("g#arcs").remove(),y.selection.select("svg").select("rect#arc-events").remove(),y.on("axesreorder.arcs",void 0),delete y.brushReset,l=void 0},selected:g,brushState:function brushState(){return m}}}(),y.interactive=function(){return h.interactive=!0,this},y.xscale=w,y.yscale=D,y.ctx=H,y.canvas=I,y.g=function(){return i},y.resize=function(){return y.selection.select("svg").attr("width",A.width).attr("height",A.height),y.svg.attr("transform","translate("+A.margin.left+","+A.margin.top+")"),h.brushable&&y.brushReset(),y.autoscale(),i&&y.createAxes(),h.brushable&&y.brushable(),h.reorderable&&y.reorderable(),B.resize.call(this,{width:A.width,height:A.height,margin:A.margin}),this},y.highlight=function(a){return 0===arguments.length?A.highlighted:(A.highlighted=a,y.clear("highlight"),d3.selectAll([I.foreground,I.brushed]).classed("faded",!0),a.forEach(r),B.highlight.call(this,a),this)},y.unhighlight=function(){return A.highlighted=[],y.clear("highlight"),d3.selectAll([I.foreground,I.brushed]).classed("faded",!1),this},y.intersection=function(e,a,b,c){return{x:((e.x*a.y-e.y*a.x)*(b.x-c.x)-(e.x-a.x)*(b.x*c.y-b.y*c.x))/((e.x-a.x)*(b.y-c.y)-(e.y-a.y)*(b.x-c.x)),y:((e.x*a.y-e.y*a.x)*(b.y-c.y)-(e.y-a.y)*(b.x*c.y-b.y*c.x))/((e.x-a.x)*(b.y-c.y)-(e.y-a.y)*(b.x-c.x))}},y.version="0.7.0",y.toString=function(){return"Parallel Coordinates: "+A.dimensions.length+" dimensions ("+d3.keys(A.data[0]).length+" total) , "+A.data.length+" rows"},y},d3.renderQueue=function(a){var b=[],// data to be rendered
c=10,// number of calls per frame
d=function(){},// clearing function
e=0,f=function(a){a&&f.data(a),f.invalidate(),d(),f.render()};// current iteration
return f.render=function(){function d(){if(!g)return!0;if(e>b.length)return!0;// Typical d3 behavior is to pass a data item *and* its index. As the
// render queue splits the original data set, we'll have to be slightly
// more carefull about passing the correct index with the data item.
for(var d=Math.min(e+c,b.length),f=e;f<d;f++)a(b[f],f);e+=c}e=0;var g=!0;f.invalidate=function(){g=!1},d3.timer(d)},f.data=function(a){return f.invalidate(),b=a.slice(0),f},f.rate=function(a){return arguments.length?(c=a,f):c},f.remaining=function(){return b.length-e},f.clear=function(a){return arguments.length?(d=a,f):(d(),f)},f.invalidate=function(){},f};